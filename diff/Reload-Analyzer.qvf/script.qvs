///$tab **Configuration **
TRACE Configuration;

/////////////////////////////////////////// REQUIRED ///////////////////////////////////////////
// IMPORTANT: To run this application, the user must be a "Tenant Admin" and must have an 
// API Key, which requires the "Developer Role" and APIs to be enabled within the tenant.

/*
1. The name of the REST connection that will be used. You must first create a valid REST connection to any endpoint to Qlik Sense tenant.
		Example: '<Space>:<Connection Name>'
        			Note: ':<Connection Name>' is the relative path which will check for a connection in the current space.
		Example Connection: 
					URL: 			https://<tenant-name>.<region>.qlikcloud.com/api/v1/items
					Header: 		"Authorization"
					Header Value: 	"Bearer <token>"
		For reference on how to connect: 
					https://qlik.dev/tutorials/generate-your-first-api-key
*/
SET vu_rest_connection = ':monitoring_apps_REST';

   
/*
2. The location where you want to store your QVDs.
		Example: '<Space>:<DataFiles>'
        			Note: ':<Connection Name>' is the relative path which will check for a connection in the current space.
*/
SET vu_qvd_storage_connection = ':DataFiles';

////////////////////////////////////////////////////////////////////////////////////////////////
///$tab * Optional Configuration *
TRACE Optional Configuration;

////////////////////////////////////////////////////////////////////////////////////////
// Optional Configuration (No need to change these unless you desire)

/*
1. The timezone difference from GMT. Modifies the reload times to desired GMT offset
		Example 1: -5
        Example 2: 5
*/
SET vu_GMT_offset = 0;

/* 
2. Maximum days back to store reload data in QVDs
		Example: 365
*/
SET vu_reload_rolling_range = 365;

/*
3. The user field to best represent the user: 'Id', 'Name', 'Subject', 'Email'
*/
SET vu_personal_space_user_field = 'Name';

/*
4. The number of days back to fetch data initially, before incrementally building
*/
SET vu_initial_days_back = 90;

/*
5. The number of days back to calculate reload concurrency by the second
*/
SET vu_reload_concurrency_days_back = 14;

/*
6. The page size to iterate over the reloads API. Must be between 1-100 (Default 100)
   This can be useful if receiving the error: "Message too large: (Connector error: Received message larger than max (x vs. y)"
   There is a 4 MB limit for the REST connector response size, so this variable controls how many reloads are brought back in one REST response
   Note that if a single reload yields too large of a result (over 4MB), this will not help. That reload may have to be skipped with SET ErrorMode = 0;
*/
SET vu_reloads_page_size = 100;

/*
7. The page size to iterate over the audits API. Must be between 1-100 (Default 100)
   This can help to relieve the weight on the audits API calls
*/
SET vu_audit_page_size = 100;


////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////
// Multi-Tenant App Configuration

// This application has support for multi-tenancy. If this app is designated as a "parent" app, it loads in the generated
// QVDs of all "child" apps from a centralized location (e.g., AWS S3, Azure Blob, or Google Cloud Storage where the 
// "QlikMetaCollection" directory resides) and does not directly harvest any data itself, meaning it depends on the existence 
// of "child" apps. If designated as a child app, it writes out all of its final QVDs post harvest to a centralized location.

SET vu_multi_tenant_enabled 			= 0;					// To enable Multi-Tenant app support, regardless of "Parent" or "Child" (1 or 0)

SET vu_is_parent_app 					= 0;					// If this application is to be the parent app across varying tenants (1 or 0)

// The connection to the parent directory of the QlikMetaCollection directory, which houses all of the multi-tenant metadata.
// This is the root location to read/write all QVDs to so that they can be loaded across tenants (S3, Azure Blob, or Google 
// Cloud Storage). The final path will resemble "QlikMetaCollection/Tenants/<TenantID>/Monitoring/<Monitoring App Name>/<Table>.qvd". 
// The location below should point to the parent directory of the "QlikMetaCollection" folder. If the "QlikMetaCollection" 
// folder does not exist, it will be automatically created.

// **Azure Blob, AWS S3, and Google CLoud Storage have been tested and confirmed to work without any modifications**
SET vu_qlik_meta_collection_parent_dir = 'lib://:';			// Parent directory of the "QlikMetaCollection" folder (trailing slash optional)

////////////////////////////////////////////////////////////////////////////////////////
///$tab << About >>
/* 

    ________     ______            _________   _______              ______                          
    ___  __ \_______  /___________ ______  /   ___    |____________ ___  /____  ____________________
    __  /_/ /  _ \_  /_  __ \  __ `/  __  /    __  /| |_  __ \  __ `/_  /__  / / /__  /_  _ \_  ___/
    _  _, _//  __/  / / /_/ / /_/ // /_/ /     _  ___ |  / / / /_/ /_  / _  /_/ /__  /_/  __/  /    
    /_/ |_| \___//_/  \____/\__,_/ \__,_/      /_/  |_/_/ /_/\__,_/ /_/  _\__, / _____/\___//_/     
                                                                         /____/                     

    Copyright 2025 QlikTech International
    Created by Daniel Pilla, Distinguished Principal Presales Architect, Qlik

	About the "Reload Analyzer" app:
    
    The Reload Analyzer is an application designed for Qlik Sense Enterprise SaaS to track and analyze 
    application reloads within the tenant(s). Some of the benefits of this application are as follows:

      - Track number of reloads by type (Scheduled, Hub, In App, API) and by User
      - View all data connections of each application's most recent reload
      - Find all applications that use a data connection
      - Analyze concurrent reloads and max concurrent Peak Reload RAM (useful for Dedicated Capacity)
      - Track reloads by Spaces
      - View all tasks and their respective statuses
      - Tie alerts into metrics, (e.g. A task has failed 5 times consecutively)

    *This application pulls 90 days of reloads, and will then continue to build from there incrementally using QVDs.

*/
///$tab Variables
SUB variables

	LET vu_tenant_fqdn 				 	= GetSysAttr('tenantUrl');
    LET vu_tenant_fqdn_alias			= GetSysAttr('tenantUrlAlias');
    
  //// Calendar Variables
  
    LET vStartTime 					= Now(1);
    LET vu_GMT_offset 				 = Replace(vu_GMT_offset,'+','');
    LET vReloadDiffFromGMTString 	 = If(vu_GMT_offset=0,'GMT-00:00',
        If(vu_GMT_offset<0,'GMT-' & Right('0' & Replace(vu_GMT_offset,'-',''),2) & ':00',
        If(vu_GMT_offset>0,'GMT+' & Right('0' & vu_GMT_offset,2) & ':00')));  
    LET vReloadTimeDiffFromGMT       = ConvertToLocalTime('$(vStartTime)','$(vReloadDiffFromGMTString)') - GMT();

    LET vLast24Hours 				= Num(Floor(TimeStamp('$(vStartTime)'-1) + $(vReloadTimeDiffFromGMT)));
    LET vLast72Hours 				= Num(Floor(TimeStamp('$(vStartTime)'-3) + $(vReloadTimeDiffFromGMT)));
    LET vLast7Days 					= Num(Floor(TimeStamp('$(vStartTime)'-7) + $(vReloadTimeDiffFromGMT)));
    LET vLast30Days	 				= Num(Floor(TimeStamp('$(vStartTime)'-30) + $(vReloadTimeDiffFromGMT)));
    LET vLast60Days 				= Num(Floor(TimeStamp('$(vStartTime)'-60) + $(vReloadTimeDiffFromGMT)));
    LET vLast90Days 				= Num(Floor(TimeStamp('$(vStartTime)'-90) + $(vReloadTimeDiffFromGMT)));
    
    LET vAPICallCounter 			 = 0;
    
    LET vMaxReloadAge        		 = TimeStamp(Date(Today(1)) - $(vu_reload_rolling_range));
    
    LET vMaxReloadConcurrencyDaysBack = TimeStamp(Date(Today(1)) - $(vu_reload_concurrency_days_back));
    
    LET v90BackGMT				 	 = Date(Today(1) - 90); // Given that the `reloads` endpoint goes back 180 but the `audits` only goes back 90, truncating both to 90

	LET vInitialDaysBack			 = If($(vu_initial_days_back)>0 AND $(vu_initial_days_back)<=90,Date(Today(1) - $(vu_initial_days_back)),$(v90BackGMT)); // If there is an initial days back setting that is between 0 and 90, set it, otherwise set it to 90

    LET vConcurrencyMinutes 		 = 1/60; // The width of the concurrency buckets for analyzing session and task concurrency. Default 1.

    LET vAppQVDName					 = Lower(Replace('$(app_name)',' ','_'));

    SET vOutputQVDName				 = 'lib://$(vu_qvd_storage_connection)/$(vAppQVDName)_$1_$2.qvd';

    SET vIncremental 				 = 1;  // Incremental load flag -- default = 1 (active). This can be disabled by setting to 0 (why do that?)
    
    LET vReloadsQVD			 		 = '$(vOutputQVDName(Reloads,$(app_schema_version)))';

    LET vIncrementalQVDsAvailable    = If(Len(FileTime('$(vReloadsQVD)'))>0,1,0);  // Check to see that incremental QVDs are available
    
    LET vIncrementalMessage 		 = If($(vIncrementalQVDsAvailable)=1,'Incremental QVDs found','No Incremental QVDs found. Do not panic. I can fix that.');
    
    SET vu_personal_space_user_list  = 'id','name','subject','email';
    
    SET vSimulateQuota				 = 0; // Temporary
    
  //// ARGB colors -- requires input value to set the intensity (alpha) value of the color.
  
    SET c_red_alpha				= 'ARGB($1,192,57,43)';
    SET c_orange_alpha			= 'ARGB($1,233,141,54)'; 
    SET c_yellow_alpha			= 'ARGB($1,237,200,58)';
    SET c_green_alpha			= 'ARGB($1,17,119,51)';
    SET c_purple_alpha			= 'ARGB($1,148,87,156)';
    SET c_blue_alpha			= 'ARGB($1,71,104,136)';
    SET c_gray_alpha 			= 'ARGB($1,89,86,90)';
    SET c_red_breeze_alpha		= 'ARGB($1,155,58,59)';
    SET c_orange_breeze_alpha	= 'ARGB($1,233,141,54)';
    SET c_teal_breeze_alpha		= 'ARGB($1,19,118,122)';
    SET c_green_breeze_alpha	= 'ARGB($1,101,177,99)';
    SET c_qlik_green_alpha		= 'ARGB($1,26,137,53)';
    SET c_red_0_green_alpha		= 'If($1=0,c_red,ARGB($1,101,177,99))';
    
    IF $(vu_is_parent_app)=0 THEN
    
        IF $(vIncrementalQVDsAvailable)=1 THEN

            ReloadMaxEndTime:
            LOAD
                Max(ReloadEndTime) AS ReloadMaxEndTime
            FROM '$(vReloadsQVD)'(qvd);

            LET vIncrementalStartTime = Peek('ReloadMaxEndTime',0,'ReloadMaxEndTime') + (1 / 24 / 60 / 60 / 1000);

            DROP TABLE ReloadMaxEndTime;

            LET vIncrementalStartTimeDisplay = TimeStamp('$(vIncrementalStartTime)','MM/DD/YYYY hh:mm:ss.fff');

            TRACE Incremental will resume from: $(vIncrementalStartTimeDisplay);

            SET vIncrementalStartTimeDisplay =;

        ELSE

            TRACE $(vIncrementalMessage);

            LET vIncrementalStartTime = '$(v90BackGMT)';

        END IF
    
    END IF
                
END SUB
///$tab Check Version
SUB check_version

    // check to see whether the app is the latest version

    LIB CONNECT TO '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "id",
        "name",
        "version",
        "source",
        "qcmaInstaller",
        "oemInstaller"
    FROM JSON (wrap on) "root"
    WITH CONNECTION (  
        URL "https://raw.githubusercontent.com/qlik-oss/qlik-cloud-monitoring-apps/main/manifests/resources.json",
        HTTPHEADER "Authorization" ""
    );

    [Version]:
    LOAD	
        [version]
    RESIDENT RestConnectorMasterTable
    WHERE name='$(app_name)';

    DROP TABLE RestConnectorMasterTable;

    LET vLatestVersion = Peek('version',0,'Version');
    LET vIsLatestVersion = If('$(vLatestVersion)'='v$(app_version)',1,0);

    DROP TABLE Version;

END SUB



///$tab Check Quota
SUB get_quota

    // Placeholder until added to license
    
    IF $(vSimulateQuota) = 1 THEN
    
        [Quotas]:
        LOAD	
            'ReloadDurationQuota' as QuotaResource,
            25 as QuotaValue,
            '$(vTenantID)' AS TenantID
        AUTOGENERATE 1;
        
    ELSE
    
    	[Quotas]:
        LOAD * INLINE [QuotaResource, QuotaValue];
    
    END IF
    
    LET vCheckForReloadDurationLicense 	= 0;
    LET vReloadDurationQuota			=-1;
    
    IF NoOfRows('Quotas') > 0 THEN
    
    	LET vCheckForReloadDurationLicense	= 1;
    	LET vReloadDurationQuota		 	= Lookup('QuotaValue','QuotaResource','ReloadDurationQuota','Quotas');
    
    ELSE
    
    	CONCATENATE(Quotas)
        LOAD
        	'$(vTenantID)' AS TenantID
        AUTOGENERATE 1;
        
	END IF
    
    
END SUB
///$tab Check Tasks Feature Flag
SUB get_tasks_feature

  	LIB CONNECT TO '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "PS-21826_Reload_Task"
    FROM JSON (wrap on) "root"
      WITH CONNECTION (  
        URL "https://$(vu_tenant_fqdn)/api/v1/features"
      );

    [TasksFeature]:
    LOAD	
        [PS-21826_Reload_Task] AS ChoreographerEnabled
    RESIDENT RestConnectorMasterTable;

    DROP TABLE RestConnectorMasterTable;

    LET vChoreographerEnabled = Alt(Fabs(Peek('ChoreographerEnabled',0,'TasksFeature')='True'),0);
    
    DROP TABLE TasksFeature;

END SUB
///$tab Tenant Metadata
SUB get_tenant_metadata

    LIB CONNECT TO '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "id",
            "name",
            "datacenter",
            "created",
            "status",
            "__FK_data",
            "__KEY_data",
            (SELECT 
                "@Value",
                "__FK_hostnames"
            FROM "hostnames" FK "__FK_hostnames" ArrayValueAlias "@Value")
        FROM "data" PK "__KEY_data" FK "__FK_data")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/tenants"
    );

    [Hostname]:
    LOAD	
        [@Value] AS Hostname
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_hostnames]);


    [TenantMetadata]:
    LOAD	
        [id] AS TenantID,
        [name] AS TenantName,
        [datacenter] AS TenantDataCenter,
        Date([created]) AS TenantCreatedDate,
        [status] AS TenantStatus,
        Peek('Hostname',0,'Hostname') AS Hostname,
        TimeStamp('$(vStartTime)') AS LastReloadStartTime
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_data]);

    DROP TABLE Hostname;
    DROP TABLE RestConnectorMasterTable;

    LET vTenantID = Peek('TenantID',0,'TenantMetadata');

    Map_TenantID_TenantName:
    MAPPING LOAD DISTINCT
        TenantID,
        TenantName
    RESIDENT TenantMetadata;

END SUB
///$tab Get User Field
SUB get_user_field

    Lookup_UserVariable_FieldName:
    LOAD * INLINE [
        UserVariable	,FieldName
        id			,ReloadUserID
        subject		,ReloadUserSubject
        email			,ReloadUserEmail
        name			,ReloadUserName
    ];

    IF Match(Lower('$(vu_personal_space_user_field)'),$(vu_personal_space_user_list)) THEN

        TRACE Using '$(vu_personal_space_user_field)' to construct 'Personal' space names;

        LET vPersonalUserField = Lookup('FieldName','UserVariable',Lower('$(vu_personal_space_user_field)'),'Lookup_UserVariable_FieldName');

    ELSE

        TRACE The value for the variable 'vu_personal_space_user_field' must contain one of: $(vu_personal_space_user_list);
        TRACE The value found was: '$(vu_personal_space_user_field)';
        TRACE Defaulting to 'Subject';

        SET vPersonalUserField = 'ReloadUserSubject';

    END IF
    
    DROP TABLE Lookup_UserVariable_FieldName;
  
END SUB
///$tab Users
SUB get_users

  SET vParams = 'limit=100';
  LET vCounter = 0;

  DO
  
  	LET vAPICallCounter = $(vAPICallCounter) + 1;
  
    LIB CONNECT TO '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "__KEY_links",
            "__FK_links",
            (SELECT 
                "href",
                "__FK_self"
            FROM "self" FK "__FK_self"),
            (SELECT 
                "href" AS "href_u0",
                "__FK_next"
            FROM "next" FK "__FK_next")
        FROM "links" PK "__KEY_links" FK "__FK_links"),
        (SELECT 
            "id",
            "tenantId",
            "created",
            "lastUpdated",
            "status",
            "name",
            "subject",
            "email",
            "__KEY_data",
            "__FK_data",
            (SELECT 
                "@Value",
                "__FK_roles"
            FROM "roles" FK "__FK_roles" ArrayValueAlias "@Value"),
            (SELECT 
                "__KEY_links_u0",
                "__FK_links_u0",
                (SELECT 
                    "href" AS "href_u1",
                    "__FK_self_u0"
                FROM "self" FK "__FK_self_u0")
            FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
        FROM "data" PK "__KEY_data" FK "__FK_data")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/users?$(vParams)"
    );


    Users:
    LOAD	
    	[id] AS ReloadUserID,
//         [id] AS UserID,
//         [tenantId],
//         Date([created]) AS ReloadUserCreatedDate,
//         Date([lastUpdated]) AS ReloadUserLastUpdatedDate,
        [status] AS ReloadUserStatus,
        [name] AS ReloadUserName,
        [subject] AS ReloadUserSubject,
        [email] AS ReloadUserEmail,
        [__KEY_data] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [_UserKey]
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_data])
    AND Match(status,'disabled','active');
    
    [UserRoles]:
    LOAD	
    	[@Value] AS UserRole,
        [__FK_roles] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [_UserKey]
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_roles]);

    NextURL:
    LOAD	
    	[href_u0] AS NextURL
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_next]);

    DROP TABLE RestConnectorMasterTable;
    
    LET vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
    LET vNextURLRows = NoOfRows('NextURL');

    DROP TABLE NextURL;
    
    LET vCounter = $(vCounter) + 1;

  LOOP WHILE $(vNextURLRows)>0;
  
  // Don't create map yet for OEM Dash support
  Map_AppOwner_Exists:
  LOAD DISTINCT
  	  ReloadUserID,
      1
  RESIDENT Users;
  
  RENAME TABLE UserRoles TO TEMP;
  
  UserRoles:
  LEFT KEEP(Users)
  LOAD *
  RESIDENT TEMP;
  
  DROP TABLE TEMP;
  
  Map_AppOwner_UserName:
  MAPPING LOAD DISTINCT
  	  ReloadUserID,
      ReloadUserName
  RESIDENT Users;
  
  Map_AppOwner_UserSubject:
  MAPPING LOAD DISTINCT
  	  ReloadUserID,
      ReloadUserSubject
  RESIDENT Users;
  
  Map_AppOwner_UserEmail:
  MAPPING LOAD DISTINCT
  	  ReloadUserID,
      ReloadUserEmail
  RESIDENT Users;
  
  Call get_user_field
  
  Map_UserID_$(vPersonalUserField):
  MAPPING LOAD DISTINCT
      ReloadUserID,
      $(vPersonalUserField)
  RESIDENT Users;
      
END SUB
///$tab Spaces
SUB get_spaces

  SET vParams = 'limit=100';
  
  [Spaces]:
  LOAD * INLINE [SpaceID];

  DO
  
    LET vAPICallCounter = $(vAPICallCounter) + 1;
  
    LIB CONNECT TO '$(vu_rest_connection)';
    
    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "id",
            "type",
            "ownerId",
            "tenantId",
            "name",
            "description",
            "createdAt",
            "createdBy",
            "updatedAt",
            "__KEY_data",
            "__FK_data",
            (SELECT 
                "__KEY_meta",
                "__FK_meta"
            FROM "meta" PK "__KEY_meta" FK "__FK_meta"),
            (SELECT 
                "__KEY_links",
                "__FK_links"
            FROM "links" PK "__KEY_links" FK "__FK_links")
        FROM "data" PK "__KEY_data" FK "__FK_data"),
        (SELECT 
            "__KEY_links_u0",
            "__FK_links_u0",
            (SELECT 
                "href" AS "href_u2",
                "__FK_next"
            FROM "next" FK "__FK_next")
        FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/spaces?$(vParams)"
    );
    
    CONCATENATE (Spaces)
    LOAD	
      [id] AS SpaceID,
      Capitalize([type]) AS SpaceType,
      [ownerId] AS SpaceOwnerID,
      // [tenantId],
      [name] AS SpaceName,
      [description] AS SpaceDescription,
      TimeStamp([createdAt]) AS SpaceCreatedTime,
      [createdBy] AS SpaceCreatedBy
      // [updatedAt],
      // [__KEY_data],
      // [__FK_data] AS [__KEY_root]
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_data]);

    NextURL:
    LOAD	
    	[href_u2] AS NextURL
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_next]);

    DROP TABLE RestConnectorMasterTable;

    LET vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
    LET vNextURLRows = NoOfRows('NextURL');

    DROP TABLE NextURL;
    
  LOOP WHILE $(vNextURLRows)>0;

  AllSpacesMap:
  MAPPING LOAD DISTINCT
      SpaceID,
      1
  RESIDENT Spaces;
  
  Map_SpaceName_SpaceID:
  MAPPING LOAD DISTINCT
  	  Text(SpaceName) AS SpaceName,
      SpaceID
  RESIDENT Spaces;
  
  Map_SpaceID_SpaceName:
  MAPPING LOAD DISTINCT
  	  SpaceID,
  	  Text(SpaceName) AS SpaceName
  RESIDENT Spaces;
  
  Map_SpaceID_OwnerID:
  MAPPING LOAD DISTINCT
  	  SpaceID,
  	  SpaceOwnerID
  RESIDENT Spaces;
  
  Map_SpaceID_SpaceType:
  MAPPING LOAD DISTINCT
  	  SpaceID,
  	  SpaceType
  RESIDENT Spaces;
  
END SUB

///$tab Data-Connections
SUB get_data_connections

  SET vParams = 'limit=100';
  
  [DataConnections]:
  LOAD * INLINE [DataConnectionID];

  DO
  
    LET vAPICallCounter = $(vAPICallCounter) + 1;
  
    LIB CONNECT TO '$(vu_rest_connection)';
    
    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "created",
            "datasourceID",
            "id",
            "qArchitecture",
            "qConnectStatement",
            "qCredentialsID",
            "qEngineObjectID",
            "qID",
            "qLogOn",
            "qName",
            "qSeparateCredentials",
            "qType",
            "space",
            "updated",
            "user",
            "version",
            "__KEY_data",
            "__FK_data"
        FROM "data" PK "__KEY_data" FK "__FK_data"),
        (SELECT 
            "__KEY_links_u0",
            "__FK_links_u0",
            (SELECT 
                "href" AS "href_u0",
                "__FK_next"
            FROM "next" FK "__FK_next")
        FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/data-connections?$(vParams)"
    );
    
    CONCATENATE (DataConnections)
    LOAD
    	'$(vTenantID)' AS DataConnectionTenantID,
        ApplyMap('Map_TenantID_TenantName','$(vTenantID)') AS DataConnectionTenantName,
    	TimeStamp([created]) AS DataConnectionCreatedTime,
		[datasourceID] AS DataConnectionDataSourceID,
        If(WildMatch([datasourceID],'DG_*'),'True','False') AS DataConnectionUsesDirectAccessGateway,
        [id] AS DataConnectionID,
//         [qArchitecture],
        [qConnectStatement] AS DataConnectionStatement,
//         [qCredentialsID],
//         [qEngineObjectID],
//         [qID],
//         [qLogOn],
        [qName] AS DataConnectionName,
//         [qSeparateCredentials],
        [qType] AS DataConnectionType,
        [space] AS DataConnectionSpaceID,
        If(Len(ApplyMap('Map_SpaceID_SpaceName',[space]))>0,
        	ApplyMap('Map_SpaceID_SpaceName',[space],'[Deleted]'),
            'Personal - ' & ApplyMap('Map_UserID_$(vPersonalUserField)',user,'DataFiles')
          ) AS DataConnectionSpaceName,
        ApplyMap('Map_SpaceID_SpaceType',[space],'[Deleted]') AS DataConnectionSpaceType,
        TimeStamp([updated]) AS DataConnectionUpdated,
        [user] AS DataConnectionUserID,
        ApplyMap('Map_UserID_$(vPersonalUserField)',[user],'[Deleted]') AS DataConnectionOwner
//         [version],
//         [__KEY_data],
//         [__FK_data] AS [__KEY_root]
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_data]);

    NextURL:
    LOAD	
        [href_u0] AS NextURL
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_next]);

    DROP TABLE RestConnectorMasterTable;

    LET vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
    LET vNextURLRows = NoOfRows('NextURL');

    DROP TABLE NextURL;
    
  LOOP WHILE $(vNextURLRows)>0;
  
  RENAME TABLE DataConnections TO TEMP;
    
  DataConnections:
  NOCONCATENATE LOAD
  	  *
  RESIDENT TEMP
  WHERE DataConnectionName <> 'MyDataFiles'
  ORDER BY DataConnectionName ASC;
  
  CONCATENATE(DataConnections)
  LOAD
      '[Unknown Endpoints Connection]' AS DataConnectionID,
      'endpoints' AS DataConnectionType,
      '[Unknown Endpoints Connection]' AS DataConnectionName,
      '[Unknown Endpoints Connection]' AS DataConnectionNameUniqueTemp
  AUTOGENERATE(1);
  
  DROP TABLE TEMP;
  
  Map_DataConnectionID_DataConnectionType:
  MAPPING LOAD DISTINCT
      DataConnectionID,
      DataConnectionType
  RESIDENT DataConnections;
  
  Map_DataConnectionID_DataConnectionSpaceID:
  MAPPING LOAD DISTINCT
      DataConnectionID,
      DataConnectionSpaceID
  RESIDENT DataConnections;
  
  Map_DataConnectionID_DataConnectionName:
  MAPPING LOAD DISTINCT
      DataConnectionID,
      DataConnectionName
  RESIDENT DataConnections;
  
  // GET FILE EXTENSIONS
  
  LET vAPICallCounter = $(vAPICallCounter) + 1;

  LIB CONNECT TO '$(vu_rest_connection)';

  RestConnectorMasterTable:
  SQL SELECT 
      "__KEY_root",
      (SELECT 
          "@Value",
          "__FK_allowedExtensions"
      FROM "allowedExtensions" FK "__FK_allowedExtensions" ArrayValueAlias "@Value"),
      (SELECT 
          "@Value" AS "@Value_u0",
          "__FK_allowedInternalExtensions"
      FROM "allowedInternalExtensions" FK "__FK_allowedInternalExtensions" ArrayValueAlias "@Value_u0")
  FROM JSON (wrap on) "root" PK "__KEY_root"
  WITH CONNECTION (  
    URL "https://$(vu_tenant_fqdn)/api/v1/data-files/quotas"
  );

  [FileExtensions]:
  LOAD	
  	  [@Value] AS FileExtension
  RESIDENT RestConnectorMasterTable
  WHERE NOT IsNull([__FK_allowedExtensions]);

  CONCATENATE(FileExtensions)
  LOAD	
  	  [@Value_u0] AS FileExtension
  RESIDENT RestConnectorMasterTable
  WHERE NOT IsNull([__FK_allowedInternalExtensions]);

  DROP TABLE RestConnectorMasterTable;
  
  Map_FileExtensions:
  MAPPING LOAD DISTINCT
  	  FileExtension,
      1
  RESIDENT FileExtensions;
  
  DROP TABLE FileExtensions;

END SUB

///$tab Apps
SUB get_apps

  SET vParams = 'limit=100&resourceType=app&noActions=true';

  DO
  
    LET vAPICallCounter = $(vAPICallCounter) + 1;
  
    LIB CONNECT TO '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "name" AS "name_u0",
            "resourceCustomAttributes",
            "resourceUpdatedAt",
            "resourceType",
            "resourceId",
            "resourceCreatedAt",
            "id" AS "id_u0",
            "createdAt",
            "updatedAt",
            "creatorId",
            "updaterId",
            "tenantId",
            "isFavorited" AS "isFavorited_u0",
            "ownerId" AS "ownerId_u0",
            "description" AS "description_u0",
            "__KEY_data",
            "__FK_data",
            (SELECT 
                "_resourcetype",
                "createdDate",
                "description",
                "dynamicColor",
                "hasSectionAccess",
                "id",
                "lastReloadTime",
                "modifiedDate",
                "name",
                "originAppId",
                "owner",
                "ownerId",
                "publishTime",
                "published",
                "spaceId",
                "thumbnail",
                "encrypted",
                "__FK_resourceAttributes"
            FROM "resourceAttributes" FK "__FK_resourceAttributes"),
            (SELECT 
                "__KEY_links",
                "__FK_links"
            FROM "links" PK "__KEY_links" FK "__FK_links"),
            (SELECT 
                "__KEY_meta",
                "__FK_meta"
            FROM "meta" PK "__KEY_meta" FK "__FK_meta")
        FROM "data" PK "__KEY_data" FK "__FK_data"),
        (SELECT 
            "__KEY_links_u0",
            "__FK_links_u0",
            (SELECT 
                "href" AS "href_u4",
                "__FK_next"
            FROM "next" FK "__FK_next")
        FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/items?$(vParams)"
    );


    [Apps]:
    LOAD
    	'$(vTenantID)' AS TenantID,
        [name_u0] AS AppName,
        // [resourceCustomAttributes],
        // [resourceUpdatedAt],
        // [resourceType],
        [resourceId] AS AppID,
        TimeStamp([resourceCreatedAt]) AS AppCreatedTime,
        // [id_u0] as [id_u0],
        // [createdAt],
        TimeStamp([updatedAt]) AS AppUpdatedTime,
        [creatorId] AS AppCreatorID,
        [updaterId] AS AppUpdaterID,
        // [tenantId],
        [isFavorited_u0] AS AppIsFavorited,
//         [ownerId_u0] AS AppOwnerID,
        [description_u0] AS AppDescription
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_data]);

    AppDetails:
    LOAD	
        // [_resourcetype],
        // [createdDate],
        // [description],
        // [dynamicColor],
        [hasSectionAccess] AS AppHasSectionAccess,
        [id] AS AppID,
        [ownerId] AS AppOwnerID,
        TimeStamp([lastReloadTime]) AS AppLastReloadTime,
        TimeStamp(TimeStamp([lastReloadTime]) + $(vReloadTimeDiffFromGMT)) AS AppLastReloadTimeLocalServerTime,
        // [modifiedDate],
        // [name],
        [originAppId] AS AppOriginalID,
//         [owner] as AppOwnerSubject,
        ApplyMap('Map_AppOwner_UserSubject',ownerId,'[Deleted]') AS AppOwnerSubject,
        ApplyMap('Map_AppOwner_UserName',ownerId,'[Deleted]') AS AppOwnerName,
        ApplyMap('Map_AppOwner_UserEmail',ownerId,'[Deleted]') AS AppOwnerEmail,
        // [ownerId],
//         [published] as AppPublished, // Only relevant for apps distributed from QSEoW
        TimeStamp([publishTime]) AS AppPublishedTime,
        If(ApplyMap('AllSpacesMap',spaceId)<>1,
            If(Len(ApplyMap('Map_UserID_$(vPersonalUserField)',ownerId,'[Deleted]'))>0,
            	'Personal - ' & ApplyMap('Map_UserID_$(vPersonalUserField)',ownerId,'[Deleted]'),
                '[Staged]'
               ),
            spaceId
            ) AS SpaceID,
        // [thumbnail],
        [encrypted] AS AppEncrypted
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_resourceAttributes])
    AND [published]<>'True';

    NextURL:
    LOAD	
    	[href_u4] AS NextURL
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_next]);

    DROP TABLE RestConnectorMasterTable;
    
    LET vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
    LET vNextURLRows = NoOfRows('NextURL');

    DROP TABLE NextURL;

  LOOP WHILE $(vNextURLRows)>0;
  
  CONCATENATE(Spaces)
  LOAD DISTINCT
      SpaceID,
      SpaceID AS SpaceName,
      'Personal' AS SpaceType,
      AppOwnerID AS SpaceOwnerID,
      '[N/A]' AS SpaceDescription,
      '[N/A]' AS SpaceCreatedTime,
      '[N/A]' AS SpaceCreatedBy
  RESIDENT AppDetails
  WHERE WildMatch(SpaceID,'Personal - *');
  
  INNER JOIN(Apps)
  LOAD 
  	  *,
      If(WildMatch(SpaceID,'Personal - *'),SpaceID,ApplyMap('Map_SpaceID_SpaceName',SpaceID)) AS AppSpaceName
  Resident AppDetails;
  
  DROP TABLE AppDetails;
  
  Map_AppID_AppName:
  MAPPING LOAD DISTINCT
  	AppID,
    AppName
  RESIDENT Apps;
  
  Map_AppID_SpaceID:
  MAPPING LOAD DISTINCT
  	  AppID,
      SpaceID
  RESIDENT Apps;
  
  Map_AllApps:
  MAPPING LOAD DISTINCT
  	  AppID,
      1
  RESIDENT Apps;
  
  // No map yet for OEM Dashboard support
  Map_AllApps_Temp:
  LOAD DISTINCT
  	  AppID,
      1
  RESIDENT Apps;
  
  Map_AppID_UserID:
  MAPPING LOAD DISTINCT
  	  AppID,
      AppOwnerID
  RESIDENT Apps;
  
END SUB
///$tab Reloads
SUB get_reloads

  SET vParams = 'limit=$(vu_reloads_page_size)';
  SET vRows = 0;
  SET vCurrentRows = 0;
  SET vContinue = 1;
  SET vAdditionalCalls = 0;
  SET vMaxAdditionalCalls = 10;

  DO
  
  	LET vAPICallCounter = $(vAPICallCounter) + 1;
  
    LIB CONNECT TO '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "id",
            "appId",
            "tenantId",
            "userId",
            "type",
            "status",
//             "log",
            "duration",
            "creationTime",
            "startTime",
            "endTime",
            "engineTime",
            "__KEY_data",
            "__FK_data",
            (SELECT 
                "__KEY_links",
                "__FK_links",
                (SELECT 
                    "href",
                    "__FK_self"
                FROM "self" FK "__FK_self")
            FROM "links" PK "__KEY_links" FK "__FK_links")
        FROM "data" PK "__KEY_data" FK "__FK_data"),
        (SELECT 
            "__KEY_links_u0",
            "__FK_links_u0",
            (SELECT 
                "href" AS "href_u0",
                "__FK_self_u0"
            FROM "self" FK "__FK_self_u0"),
            (SELECT 
                "href" AS "href_u1",
                "__FK_next"
            FROM "next" FK "__FK_next")
        FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/reloads?$(vParams)"
    );

	IF $(vIncrementalQVDsAvailable)=1 THEN
    
        [Reloads]:
        LOAD	
            [id] AS ReloadID,
            [appId] AS AppID,
            [userId] AS ReloadUserID,
//             [userId] AS UserID,
            [type] AS ReloadType,
            [status] AS ReloadStatus,
    //         [log] AS ReloadLog,
    //         [duration] AS ReloadDuration,
            endTime,
            Interval(TimeStamp([endTime]) - TimeStamp([startTime]), 'hh:mm:ss.fff') AS ReloadDuration,
            TimeStamp([endTime]) - TimeStamp([startTime]) AS ReloadDurationNum,
            TimeStamp([startTime]) AS ReloadStartDate,
            Date(TimeStamp([creationTime])) AS ReloadCreationTime,
            TimeStamp([startTime]) AS ReloadStartTime,
            Hour(TimeStamp([startTime])) AS ReloadStartHour,
            Minute(TimeStamp([startTime])) AS ReloadStartMinute,
            TimeStamp([endTime]) AS ReloadEndTime,
            TimeStamp([engineTime]) AS ReloadEngineTime
        RESIDENT RestConnectorMasterTable
        WHERE NOT IsNull([__FK_data])
        AND Match(status,'SUCCEEDED','FAILED','CANCELED')
        AND TimeStamp(endTime) >= TimeStamp('$(vIncrementalStartTime)')
        AND TimeStamp(endTime) >= TimeStamp('$(v90BackGMT)');
  
        LET vCurrentRows = NoOfRows('Reloads');
        
        IF $(vCurrentRows) <> $(vRows) THEN
        	LET vRows = $(vCurrentRows);
            SET vContinue = 1;
        ELSE
        	IF $(vMaxAdditionalCalls) = $(vAdditionalCalls) THEN
        		SET vContinue = 0;
            ELSE
            	LET vAdditionalCalls = $(vAdditionalCalls) + 1;
            END IF
        END IF
        
    ELSE
    
        [Reloads]:
        LOAD	
            [id] AS ReloadID,
            [appId] AS AppID,
            [userId] AS ReloadUserID,
//             [userId] AS UserID,
            [type] AS ReloadType,
            [status] AS ReloadStatus,
    //         [log] AS ReloadLog,
    //         [duration] AS ReloadDuration,
            endTime,
            Interval(TimeStamp([endTime]) - TimeStamp([startTime]), 'hh:mm:ss.fff') AS ReloadDuration,
            TimeStamp([endTime]) - TimeStamp([startTime]) AS ReloadDurationNum,
            TimeStamp([startTime]) AS ReloadStartDate,
            Date(TimeStamp([creationTime])) AS ReloadCreationTime,
            TimeStamp([startTime]) AS ReloadStartTime,
            Hour(TimeStamp([startTime])) AS ReloadStartHour,
            Minute(TimeStamp([startTime])) AS ReloadStartMinute,
            TimeStamp([endTime]) AS ReloadEndTime,
            TimeStamp([engineTime]) AS ReloadEngineTime
        RESIDENT RestConnectorMasterTable
        WHERE NOT IsNull([__FK_data])
        AND Match(status,'SUCCEEDED','FAILED','CANCELED')
        AND TimeStamp(endTime) >= TimeStamp('$(vInitialDaysBack)')
        AND TimeStamp(endTime) >= TimeStamp('$(v90BackGMT)');
        
        LET vCurrentRows = NoOfRows('Reloads');
        
        IF $(vCurrentRows) <> $(vRows) THEN
        	LET vRows = $(vCurrentRows);
            SET vContinue = 1;
        ELSE
        	IF $(vMaxAdditionalCalls) = $(vAdditionalCalls) THEN
        		SET vContinue = 0;
            ELSE
            	LET vAdditionalCalls = $(vAdditionalCalls) + 1;
            END IF
        END IF
    
    END IF

    [NextURL]:
    LOAD	
        [href_u1] AS NextURL
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_next]);

    DROP TABLE RestConnectorMasterTable;

    LET vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
    LET vNextURLRows = NoOfRows('NextURL');

    DROP TABLE NextURL;
    
  LOOP WHILE $(vNextURLRows)>0 AND $(vContinue);
  
  DROP FIELD endTime;
  
  LET vNoOfReloads = NoOfRows('Reloads');
  TRACE number of reloads: $(vNoOfReloads);

  Map_All_Reload_Jobs:
  MAPPING LOAD DISTINCT
      ReloadID,
      1
  RESIDENT Reloads;

END SUB
///$tab Reload-Tasks
SUB get_reload_tasks

  ReloadTasks:
  LOAD * INLINE [ReloadTaskID];

  SET vParams = 'limit=100';
  LET vCounter = 0;
  
  DO
  
  	LET vAPICallCounter = $(vAPICallCounter) + 1;

    LIB CONNECT TO '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "id",
            "type",
            "active",
            "appId",
            "startDateTime",
            "state",
            "timeZone",
            "nextExecutionTime",
            "lastExecutionTime",
            "__KEY_data",
            "__FK_data",
            (SELECT 
                "@Value",
                "__FK_recurrence"
            FROM "recurrence" FK "__FK_recurrence" ArrayValueAlias "@Value"),
            (SELECT 
                "__KEY_links",
                "__FK_links",
                (SELECT 
                    "href",
                    "__FK_self"
                FROM "self" FK "__FK_self")
            FROM "links" PK "__KEY_links" FK "__FK_links")
        FROM "data" PK "__KEY_data" FK "__FK_data"),
        (SELECT 
            "__KEY_links_u0",
            "__FK_links_u0",
            (SELECT 
                "href" AS "href_u0",
                "__FK_self_u0"
            FROM "self" FK "__FK_self_u0"),
            (SELECT 
                "href" AS "href_u1",
                "__FK_next"
            FROM "next" FK "__FK_next")
        FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/reload-tasks?$(vParams)"
    );

    [Recurrence]:
    LOAD	
    	[@Value] AS ReloadTaskRecurrence,
        Capitalize(TextBetween([@Value],'FREQ=',';')) AS ReloadTaskRecurrenceRate,
        [__FK_recurrence] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_recurrence]);

    CONCATENATE(ReloadTasks)
    LOAD	
	  [id] AS ReloadTaskID,
      'Scheduled' AS ReloadTaskType,
      //[active] AS ReloadTaskActive,
      [appId] AS AppID,
      ApplyMap('Map_AppID_UserID',appId,'[Deleted]') AS ReloadTaskOwnerID,
      ApplyMap('Map_AppOwner_UserName',ApplyMap('Map_AppID_UserID',appId,'[Deleted]'),'[Deleted]') AS ReloadTaskOwnerName,
      Date(TimeStamp(TimeStamp([startDateTime]) + $(vReloadTimeDiffFromGMT))) AS ReloadTaskStartDateTime,
      [state] AS ReloadTaskState,
      [timeZone] AS ReloadTaskTimeZone,
      Date(TimeStamp(TimeStamp([nextExecutionTime]) + $(vReloadTimeDiffFromGMT))) AS ReloadTaskNextExecutionTime,
      Date(TimeStamp(TimeStamp([lastExecutionTime]) + $(vReloadTimeDiffFromGMT))) AS ReloadTaskLastExecutionTime,
      Null() AS ReloadTaskKeepActive, // Keeping schema the same as Tasks in case not yet available
      Null() AS ReloadTaskDescription, // Keeping schema the same as Tasks in case not yet available
      Null() AS ReloadTaskName, // Keeping schema the same as Tasks in case not yet available
      [__KEY_data] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_data]);
    
    [NextURL]:
    LOAD	
        [href_u1] AS NextURL
    RESIDENT RestConnectorMasterTable
    WHERE NOT IsNull([__FK_next]);

    DROP TABLE RestConnectorMasterTable;

    LET vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
    LET vNextURLRows = NoOfRows('NextURL');

    DROP TABLE NextURL;
    
    LET vCounter = $(vCounter) + 1;

  LOOP WHILE $(vNextURLRows)>0;
  
  LEFT JOIN (ReloadTasks)
  LOAD * RESIDENT Recurrence;

  RENAME TABLE ReloadTasks TO TEMP;
  DROP TABLE Recurrence;
  DROP FIELD [__KEY_data];

  ReloadTasks:
  LEFT KEEP(Apps)
  LOAD * RESIDENT TEMP;

  DROP TABLE TEMP;

END SUB
///$tab Tasks
SUB get_tasks

	IF $(vChoreographerEnabled) THEN

        LET vCounter = 0;
        SET vParams = 'limit=100';

        DO

            LET vAPICallCounter = $(vAPICallCounter) + 1;

            LIB CONNECT TO '$(vu_rest_connection)';

            RestConnectorMasterTable:
            SQL SELECT 
                "__KEY_root",
                (SELECT 
                    "description",
                    "enabled",
                    "id" AS "id_u1",
                    "name" AS "name_u2",
                    "resourceId",
                    "specVersion",
                    "version",
                    "keepActive",
                    "__KEY_data",
                    "__FK_data",
                    (SELECT 
                        "createdAt",
                        "createdBy",
                        "fortressId",
                        "ownerId",
                        "spaceId",
                        "tenantId",
                        "updatedAt",
                        "disabledCode",
                        "__KEY_metadata",
                        "__FK_metadata",
                        (SELECT 
                            "id",
                            "type",
                            "__KEY_orchestration",
                            "__FK_orchestration",
                            (SELECT 
                                "last_run_endedAt",
                                "last_run_startedAt",
                                "last_run_status",
                                "last_run_worker_type",
                                "next_run_at",
                                "__FK_attrs"
                            FROM "attrs" FK "__FK_attrs")
                        FROM "orchestration" PK "__KEY_orchestration" FK "__FK_orchestration"),
                        (SELECT 
                            "id" AS "id_u0",
                            "type" AS "type_u0",
                            "__FK_trigger"
                        FROM "trigger" FK "__FK_trigger")
                    FROM "metadata" PK "__KEY_metadata" FK "__FK_metadata"),
                    (SELECT 
                        "__KEY_start",
                        "__FK_start",
                        (SELECT 
                            "recurrence",
                            "startDateTime",
                            "timezone",
                            "__FK_schedule"
                        FROM "schedule" FK "__FK_schedule")
                    FROM "start" PK "__KEY_start" FK "__FK_start"),
                    (SELECT 
                        "name" AS "name_u0",
                        "type" AS "type_u1",
                        "__KEY_states",
                        "__FK_states",
                        (SELECT 
                            "__KEY_onEvents",
                            "__FK_onEvents",
                            (SELECT 
                                "name",
                                "__KEY_actions",
                                "__FK_actions",
                                (SELECT 
                                    "refName",
                                    "__KEY_functionRef",
                                    "__FK_functionRef",
                                    (SELECT 
                                        "appId",
                                        "partial",
                                        "__FK_arguments"
                                    FROM "arguments" FK "__FK_arguments")
                                FROM "functionRef" PK "__KEY_functionRef" FK "__FK_functionRef")
                            FROM "actions" PK "__KEY_actions" FK "__FK_actions"),
                            (SELECT 
                                "@Value",
                                "__FK_eventRefs"
                            FROM "eventRefs" FK "__FK_eventRefs" ArrayValueAlias "@Value")
                        FROM "onEvents" PK "__KEY_onEvents" FK "__FK_onEvents")
                    FROM "states" PK "__KEY_states" FK "__FK_states"),
                    (SELECT 
                        "name" AS "name_u1",
                        "source",
                        "type" AS "type_u2",
                        "__KEY_events",
                        "__FK_events",
                        (SELECT 
                            "contextAttributeName",
                            "contextAttributeValue",
                            "__FK_correlation"
                        FROM "correlation" FK "__FK_correlation")
                    FROM "events" PK "__KEY_events" FK "__FK_events")
                FROM "data" PK "__KEY_data" FK "__FK_data"),
                (SELECT 
                    "__KEY_links",
                    "__FK_links",
                    (SELECT 
                        "href",
                        "__FK_self"
                    FROM "self" FK "__FK_self"),
                    (SELECT 
                        "href" AS "href_u0",
                        "__FK_next"
                    FROM "next" FK "__FK_next")
                FROM "links" PK "__KEY_links" FK "__FK_links")
            FROM JSON (wrap on) "root" PK "__KEY_root"
            WITH CONNECTION (  
                URL "https://$(vu_tenant_fqdn)/api/v1/tasks?$(vParams)"
            );


            [TaskAttrs]:
            LOAD	
    //         	[last_run_endedAt],
                Date(TimeStamp(TimeStamp([last_run_startedAt]) + $(vReloadTimeDiffFromGMT))) AS ReloadTaskLastExecutionTime,
    //         	[last_run_status],
    //         	[last_run_worker_type],
                Date(TimeStamp(TimeStamp([next_run_at]) + $(vReloadTimeDiffFromGMT))) AS ReloadTaskNextExecutionTime,
                [__FK_attrs] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_orchestration]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_attrs]);


            [TasksOrchestration]:
            LOAD	
    //         	[id],
    //         	[type],
                [__KEY_orchestration] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_orchestration],
                [__FK_orchestration] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_metadata]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_orchestration]);


            // [trigger]:
            // LOAD	[id_u0] AS [id_u0],
            // 	[type_u0] AS [type_u0],
            // 	[__FK_trigger] AS [__KEY_metadata]
            // RESIDENT RestConnectorMasterTable
            // WHERE NOT IsNull([__FK_trigger]);

            [TasksMetadata]:
            LOAD	
    //         	[createdAt],
    //         	[createdBy],
    //         	[fortressId],
                [ownerId] AS ReloadTaskOwnerID,
                ApplyMap('Map_AppOwner_UserName',[ownerId],'[Deleted]') AS ReloadTaskOwnerName,
    //         	[spaceId],
    //         	[tenantId],
    //         	[updatedAt],
    //         	[disabledCode],
                [__KEY_metadata] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_metadata],
                [__FK_metadata] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_metadata]);

            [TasksSchedule]:
            LOAD	
                [recurrence] AS ReloadTaskRecurrence,
                Capitalize(TextBetween([recurrence],'FREQ=',';')) AS ReloadTaskRecurrenceRate,
                Date(TimeStamp(TimeStamp([startDateTime]) + $(vReloadTimeDiffFromGMT))) AS ReloadTaskStartDateTime,
                [timezone] AS ReloadTaskTimeZone,
                [__FK_schedule]  & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_start]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_schedule]);

            [TasksStart]:
            LOAD	
                [__KEY_start]  & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_start],
                [__FK_start] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_start]);


            // [arguments]:
            // LOAD	[appId],
            // 	[partial],
            // 	[__FK_arguments] AS [__KEY_functionRef]
            // RESIDENT RestConnectorMasterTable
            // WHERE NOT IsNull([__FK_arguments]);


            // [functionRef]:
            // LOAD	[refName],
            // 	[__KEY_functionRef],
            // 	[__FK_functionRef] AS [__KEY_actions]
            // RESIDENT RestConnectorMasterTable
            // WHERE NOT IsNull([__FK_functionRef]);


            // [actions]:
            // LOAD	[name],
            // 	[__KEY_actions],
            // 	[__FK_actions] AS [__KEY_onEvents]
            // RESIDENT RestConnectorMasterTable
            // WHERE NOT IsNull([__FK_actions]);


    //         [eventRefs]:
    //         LOAD	[@Value],
    //         	[__FK_eventRefs] AS [__KEY_onEvents]
    //         RESIDENT RestConnectorMasterTable
    //         WHERE NOT IsNull([__FK_eventRefs]);


    //         [onEvents]:
    //         LOAD	[__KEY_onEvents],
    //         	[__FK_onEvents] AS [__KEY_states]
    //         RESIDENT RestConnectorMasterTable
    //         WHERE NOT IsNull([__FK_onEvents]);


            // [states]:
            // LOAD	[name_u0] AS [name_u0],
            // 	[type_u1] AS [type_u1],
            // 	[__KEY_states],
            // 	[__FK_states] AS [__KEY_data]
            // RESIDENT RestConnectorMasterTable
            // WHERE NOT IsNull([__FK_states]);


            [ReloadTaskParentID]:
            LOAD	
            	[contextAttributeValue] AS ReloadTaskParentID,
            	[__FK_correlation] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_events]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_correlation])
            AND [contextAttributeName]='id';
            
            [ReloadTaskParentStatus]:
            LOAD	
            	[contextAttributeValue] AS ReloadTaskParentStatus,
            	[__FK_correlation] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_events]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_correlation])
            AND [contextAttributeName]='status';

            [ReloadTaskEvents]:
            LOAD	
                //Subfield([name_u1],'-',-1) AS ReloadTaskParentStatus,
                //ExtractRegEx([name_u1],'[({]?[a-fA-F0-9]{8}[-]?([a-fA-F0-9]{4}[-]?){3}[a-fA-F0-9]{12}[})]?') AS ReloadTaskParentID, // the reload parent ID GUID is nested in a string. gnarly.
                //[source],
                //[type_u2] AS [type_u2],
                [__KEY_events] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_events],
                [__FK_events] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_events]);

            [Tasks]:
            LOAD	
                [description] AS ReloadTaskDescription,
                Pick(Match([enabled],'True','False'),'Enabled','Disabled') AS ReloadTaskState,
                [id_u1] AS ReloadTaskID,
                [name_u2] AS ReloadTaskName,
                [resourceId] AS AppID,
                //[specVersion],
                //[version],
                If([keepActive]='False','False','True') AS ReloadTaskKeepActive,
                [__KEY_data] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_data]);

            [NextURL]:
            LOAD	
                [href_u0] AS NextURL
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_next]);

            DROP TABLE RestConnectorMasterTable;

            LET vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);

            LET vNextURLRows = NoOfRows('NextURL');

            DROP TABLE NextURL;

            LET vCounter = $(vCounter) + 1;

        LOOP WHILE $(vNextURLRows)>0;

        LEFT JOIN (Tasks)
        LOAD * RESIDENT TasksStart;

        LEFT JOIN (Tasks)
        LOAD * RESIDENT TasksSchedule;

        LEFT JOIN (Tasks)
        LOAD * RESIDENT TasksMetadata;

        LEFT JOIN (Tasks)
        LOAD * RESIDENT TasksOrchestration;

        LEFT JOIN (Tasks)
        LOAD * RESIDENT TaskAttrs;

        DROP TABLES
            TasksSchedule
            ,TasksStart
            ,TasksMetadata
            ,TasksOrchestration
            ,TaskAttrs
            ;

        Map_TaskID_TaskName:
        MAPPING LOAD DISTINCT
            ReloadTaskID,
            ReloadTaskName
        RESIDENT Tasks;
        
        LEFT JOIN(ReloadTaskEvents)
        LOAD DISTINCT
        	*
        RESIDENT ReloadTaskParentStatus;
        
        DROP TABLE ReloadTaskParentStatus;
        
        LEFT JOIN(ReloadTaskEvents)
        LOAD DISTINCT
        	*
        RESIDENT ReloadTaskParentID;
        
        DROP TABLE ReloadTaskParentID;

        // Join the parent task name to the parent task ID
        LEFT JOIN(ReloadTaskEvents)
        LOAD DISTINCT
            ReloadTaskParentID,
            ApplyMap('Map_TaskID_TaskName',ReloadTaskParentID,'Unknown') AS ReloadTaskParentName
        RESIDENT ReloadTaskEvents;

        // Join the task children to the events, since the events map to the parents
        LEFT JOIN(ReloadTaskEvents)
        LOAD DISTINCT
            ReloadTaskID,
            ReloadTaskID AS ReloadTaskChildID,
            ReloadTaskName AS ReloadTaskChildName,
            [__KEY_data]
        RESIDENT Tasks;

        DROP FIELDS 
            [__KEY_data]
            ,[__KEY_start]
            ,[__KEY_orchestration]
            ,[__KEY_metadata]
            ,[__KEY_events]
            ;

        RENAME TABLE Tasks TO TEMP;

        // Remove all tasks without existing apps -- was an issue before, being safe
        Tasks:
        LEFT KEEP(Apps)
        LOAD * RESIDENT TEMP;

        DROP TABLE TEMP;

        RENAME TABLE ReloadTaskEvents TO TEMP;

        // Remove all events without existing apps -- was an issue before, being safe
        ReloadTaskEvents:
        LEFT KEEP(Tasks)
        LOAD 
            ReloadTaskParentID AS ReloadTaskID,
            ReloadTaskChildID,
            ReloadTaskChildName,
            ReloadTaskParentID,
            ReloadTaskParentName,
            ReloadTaskParentStatus
        RESIDENT TEMP;

        DROP TABLE TEMP;

        // Create a mapping table to track which task IDs are child tasks
        Map_IsTaskChild:
        MAPPING LOAD DISTINCT
            ReloadTaskChildID,
            1
        RESIDENT ReloadTaskEvents; 

        // Create status mapping
        Map_ReloadTaskChildID_Status:
        MAPPING LOAD DISTINCT
            ReloadTaskChildID,
            ReloadTaskParentStatus
        RESIDENT ReloadTaskEvents;

        RENAME FIELD ReloadTaskRecurrenceRate TO ReloadTaskRecurrenceRateTemp;

        // Infer what type of reload schedule it is based on if it has a schedule or not
        CONCATENATE(ReloadTasks)
        LOAD
            *,
            If(Len(ReloadTaskRecurrenceRateTemp)>0,'Scheduled','Triggered') AS ReloadTaskType,
            Coalesce(ReloadTaskRecurrenceRateTemp,'Triggered') AS ReloadTaskRecurrenceRate
        RESIDENT Tasks;

        DROP TABLE Tasks;
        DROP FIELD ReloadTaskRecurrenceRateTemp;

        // Create a mapping load to map each task to its respective app
        Map_ReloadTaskID_AppID:
        MAPPING LOAD DISTINCT
            ReloadTaskID,
            AppID
        RESIDENT ReloadTasks;

        // The Org Chart viz requires a specific setup. It was easier to alias the fields specifically for the chart
        ReloadTaskEventsForTreeViz:
        LOAD DISTINCT
            ReloadTaskChildID AS ReloadTaskChildIDViz,
            ReloadTaskChildName AS ReloadTaskChildNameViz,
            ReloadTaskParentID AS ReloadTaskParentIDViz,
            ReloadTaskParentName AS ReloadTaskParentNameViz,
            ReloadTaskParentStatus AS ReloadTaskParentStatusViz,
            ApplyMap('Map_AppID_AppName',ApplyMap('Map_ReloadTaskID_AppID',ReloadTaskChildID,'Unknown'),'Unknown') AS ReloadTaskChildAppIDViz,
            ReloadTaskID AS ReloadTaskIDTemp
        RESIDENT ReloadTaskEvents;

        // The Org Chart looks lousy without a top level parent entity, so tying all the root nodes into that
        CONCATENATE(ReloadTaskEventsForTreeViz)
        LOAD DISTINCT
            'Tasks' AS ReloadTaskParentIDViz,
            'Tasks' AS ReloadTaskParentNameViz,
            ReloadTaskID AS ReloadTaskIDTemp,
            ReloadTaskID AS ReloadTaskChildIDViz,
            ReloadTaskName AS ReloadTaskChildNameViz,
            ApplyMap('Map_AppID_AppName',ApplyMap('Map_ReloadTaskID_AppID',ReloadTaskID,'Unknown'),'Unknown') AS ReloadTaskChildAppIDViz
        RESIDENT ReloadTasks
        WHERE NOT EXISTS(ReloadTaskChildIDViz,ReloadTaskID);

        // Fabricated root entity
        CONCATENATE(ReloadTaskEventsForTreeViz)
        LOAD
            'Tasks' AS ReloadTaskChildIDViz,
            'Tasks' AS ReloadTaskChildNameViz
        AUTOGENERATE 1;

        // This bit is pretty wild and likely overkill, but it is repurposed from the SaaS Readiness app which I wrote many moons ago.
        // It generates a table for each level in the hierarchy of the reload tasks, each one hanging off the subsequent, up to 100 deep.
        // This will then be used for the pivot table visualization
        IF NoOfRows('ReloadTaskEvents')>0 THEN

            i = 1;

            DO 
                z = $(i) - 1;

                IF $(i)=1 THEN

                  TaskHierarchyChild$(i):
                  LOAD
                      ReloadTaskParentID,
                      ReloadTaskParentID AS ReloadTaskParentID$(i),
                      ReloadTaskParentName AS ReloadTaskParentName$(i),
                      ReloadTaskChildID AS ReloadTaskChildID$(i),
                      ReloadTaskChildName AS ReloadTaskChildName$(i),
                      ReloadTaskParentStatus AS ReloadTaskParentStatus$(i)
                  RESIDENT ReloadTaskEvents
                  WHERE ApplyMap('Map_IsTaskChild',ReloadTaskParentID,Null())<>1;

                  TaskHierarchyChildMap$(i):
                  MAPPING LOAD DISTINCT
                      ReloadTaskChildID$(i),
                      1
                  RESIDENT TaskHierarchyChild$(i);

                ELSE

                    TaskHierarchyChild$(i):
                    LOAD
                        ReloadTaskParentID AS ReloadTaskParentID$(i),
                        ReloadTaskParentName AS ReloadTaskParentName$(i),
                        ReloadTaskChildID AS ReloadTaskChildID$(i),
                        ReloadTaskParentID AS ReloadTaskChildID$(z),
                        ReloadTaskChildName AS ReloadTaskChildName$(i),
                        ReloadTaskParentStatus AS ReloadTaskParentStatus$(i)
                    RESIDENT ReloadTaskEvents
                    WHERE ApplyMap('TaskHierarchyChildMap$(z)',ReloadTaskParentID)=1;

                    IF NoOfRows('TaskHierarchyChild$(i)') < 1 THEN
                        DROP TABLE TaskHierarchyChild$(i);
                        EXIT DO
                    END IF

                    TaskHierarchyChildMap$(i):
                    MAPPING LOAD
                        ReloadTaskChildID$(i),
                        1
                    RESIDENT TaskHierarchyChild$(i);

                    LET vRows = NoOfRows('TaskHierarchyChild$(z)');

                END IF

                LET i = i+1;

            LOOP WHILE i<=100;

		ELSE
        
        	// Placeholder table
            TaskHierarchyChild1:
            LOAD
                Null() AS ReloadTaskParentID,
                Null() AS ReloadTaskParentID1,
                Null() AS ReloadTaskParentName1,
                Null() AS ReloadTaskChildID1,
                Null() AS ReloadTaskChildName1,
                Null() AS ReloadTaskParentStatus1
            AUTOGENERATE 1;

        END IF

        // Now we're going to roll it all back up so that each child task is mapped to the root with its corresponding hierarchy level.
        // The script below will iterate through the tables that were generated and join them to their root tasks
        RootParentTasks:
        LOAD DISTINCT
            ReloadTaskParentID AS ReloadTaskParentID1
        RESIDENT ReloadTaskEvents
        WHERE ApplyMap('Map_IsTaskChild',ReloadTaskParentID,Null())<>1;

        LET i = 1;

        DO

            IF i = 1 THEN

                LEFT JOIN (RootParentTasks)
                LOAD DISTINCT
                    ReloadTaskParentID$(i),
                    ReloadTaskChildID$(i)
                RESIDENT 'TaskHierarchyChild$(i)';

            ELSE

                LET z = $(i)-1;

                LEFT JOIN (RootParentTasks)
                LOAD DISTINCT
                    ReloadTaskChildID$(i),
                    ReloadTaskChildID$(z)
                RESIDENT 'TaskHierarchyChild$(i)';

            END IF

        LET i = $(i) + 1;

        LOOP WHILE NoOfRows('TaskHierarchyChild$(i)') > 0;

        // Now we will crosstable it so we can get each child field into a single column
        ReloadTaskChildFlatTemp:
        CrossTable(ReloadTaskHierarchyLevel,ReloadTaskHierarchyChildID)
        LOAD 
            ReloadTaskParentID1 AS ReloadTaskID,
            *
        RESIDENT RootParentTasks;

        DROP TABLE RootParentTasks;

        // This now creates a hierarchical level field using the name of the child field from before, where the root
        // becomes level 1 and so on
        ReloadTaskChildFlat:
        NOCONCATENATE
        LOAD
            ReloadTaskID,
            If(ReloadTaskID = ReloadTaskHierarchyChildID,1,Subfield(ReloadTaskHierarchyLevel,'ReloadTaskChildID',-1)+1) as ReloadTaskHierarchyLevel,
            If(ReloadTaskID = ReloadTaskHierarchyChildID,'True','False') AS ReloadTaskIsRoot,
            ReloadTaskHierarchyChildID,
            ApplyMap('Map_TaskID_TaskName',ReloadTaskHierarchyChildID,'Unknown') AS ReloadTaskHierarchyChildName,
            ApplyMap('Map_ReloadTaskChildID_Status',ReloadTaskHierarchyChildID,Null()) AS ReloadTaskHierarchyParentStatus
        RESIDENT ReloadTaskChildFlatTemp;

        DROP TABLE ReloadTaskChildFlatTemp;

        // Flag all root tasks from the table above
        Map_IsReloadTaskParent:
        MAPPING LOAD DISTINCT
            ReloadTaskID,
            1
        RESIDENT ReloadTaskChildFlat
        WHERE ReloadTaskIsRoot = 'True';

        // Concatenate on all root tasks that do not have children
        CONCATENATE(ReloadTaskChildFlat)
        LOAD DISTINCT
            ReloadTaskID,
            ReloadTaskID AS ReloadTaskHierarchyChildID,
            ReloadTaskName AS ReloadTaskHierarchyChildName,
            1 AS ReloadTaskHierarchyLevel,
            'True' AS ReloadTaskIsRoot
        RESIDENT ReloadTasks
        WHERE ApplyMap('Map_IsReloadTaskParent',ReloadTaskID,Null())<>1
        AND ApplyMap('Map_IsTaskChild',ReloadTaskID,Null())<>1;

        // Create a map to map on the hierarchys
        Map_ReloadTaskID_Level:
        MAPPING LOAD DISTINCT
            ReloadTaskHierarchyChildID,
            ReloadTaskHierarchyLevel
        RESIDENT ReloadTaskChildFlat;

        // Now we link the AppIDs to the entirety of the reload chain that they are associated with, so if you select
        // a single app, you will see every chain that it is a part of
        ReloadTaskHierarchyLink:
        LOAD DISTINCT
            ReloadTaskID,
            ApplyMap('Map_ReloadTaskID_AppID',ReloadTaskHierarchyChildID,'Unknown') AS AppID
        RESIDENT ReloadTaskChildFlat;

        // Associating all levels as per the above to all respective apps
        CONCATENATE(ReloadTaskHierarchyLink)
        LOAD DISTINCT
            ReloadTaskHierarchyChildID AS ReloadTaskID,
            ApplyMap('Map_ReloadTaskID_AppID',ReloadTaskHierarchyChildID,'Unknown') AS AppID
        RESIDENT ReloadTaskChildFlat;

        RENAME TABLE ReloadTasks TO TEMP;

        // Have to get rid of AppID field and you can't drop a key from only some tables, so loading all
        // other fields
        ReloadTasks:
        LOAD DISTINCT
            ReloadTaskID,
            ReloadTaskOwnerID,
            ReloadTaskOwnerName,
            ReloadTaskRecurrence,
            ReloadTaskRecurrenceRate,
            ReloadTaskType,
            ReloadTaskStartDateTime,
            ReloadTaskState,
            ReloadTaskTimeZone,
            ReloadTaskNextExecutionTime,
            ReloadTaskLastExecutionTime,
            ReloadTaskDescription,
            ReloadTaskName,
            ReloadTaskKeepActive,
            If(ApplyMap('Map_IsTaskChild',ReloadTaskID,Null())<>1,1,0) AS ReloadTaskIsRoot
        RESIDENT TEMP;

        DROP TABLE TEMP;

        // Make sure that the org chart hierarchies roll up to their full task chains by mapping the root IDs 
        // on from the flattened hierarchy
        LEFT JOIN(ReloadTaskEventsForTreeViz)
        LOAD DISTINCT
            ReloadTaskHierarchyChildID AS ReloadTaskIDTemp,
            ReloadTaskID
        RESIDENT ReloadTaskChildFlat;

        // Needed to use a temp field again because it is a key
        DROP FIELD ReloadTaskIDTemp;

        // Join on all hierarchy levels
        LEFT JOIN (ReloadTaskEvents)
        LOAD DISTINCT
            ReloadTaskChildID,
            ApplyMap('Map_ReloadTaskID_Level',ReloadTaskID,Null()) AS ReloadTaskChildHierarchyLevel
        RESIDENT ReloadTaskEvents;

        // Drop flattened hierarchies
        DROP TABLE ReloadTaskChildFlat;

        // Tack on hierarchy to org chart viz
        LEFT JOIN(ReloadTaskEventsForTreeViz)
        LOAD DISTINCT
            ReloadTaskChildIDViz,
            ApplyMap('Map_ReloadTaskID_Level',ReloadTaskChildIDViz,Null()) AS ReloadTaskChildHierarchyLevelViz
        RESIDENT ReloadTaskEventsForTreeViz;
        
        // Cleanup placeholder table
        IF NOT NoOfRows('ReloadTaskEvents')>0 THEN
        	DROP TABLE TaskHierarchyChild1;
        END IF
        
    END IF

END SUB
///$tab Trigger Audit Reloads
SUB get_audit_reloads

	// reload.ended event has been removed from all tenants, call finished directly
    CALL get_audit_reloads_finished;

END SUB
///$tab Audit Reloads (.finished)
SUB get_audit_reloads_finished

    LET vCounter = 0;
    LET vNextURL = '';
    LET vUniqueKey = Num('$(reload_start)') & '$(vTenantID)';
    
    IF $(vIncrementalQVDsAvailable)=1 THEN
    	LET vISO_8601_Date_Range = '&eventTime=' & Left(Date(TimeStamp('$(vIncrementalStartTime)'),'YYYY-MM-DD'),10) & 'T' & Right('0' & Timestamp('$(vIncrementalStartTime)','MM/DD/YYYY hh:mm:ss'),8) & 'Z/9999-01-01T00:00:00Z';
    ELSE
    	LET vISO_8601_Date_Range = '&eventTime=' & Left(Date(TimeStamp('$(vInitialDaysBack)'),'YYYY-MM-DD'),10) & 'T' & Right('0' & Timestamp('$(vInitialDaysBack)','MM/DD/YYYY hh:mm:ss'),8) & 'Z/9999-01-01T00:00:00Z';
    END IF
                
    DO
    	LET vAPICallCounter = $(vAPICallCounter) + 1;

        LIB CONNECT TO '$(vu_rest_connection)';

        RestConnectorMasterTable:
        SQL SELECT 
            "__KEY_root",
            (SELECT 
                "id",
                "contentType",
                "eventId",
                "eventTime",
                "eventType",
                "eventTypeVersion",
                "source",
                "tenantId",
                "userId",
                "__KEY_data",
                "__FK_data",
                (SELECT 
                    "duration",
                    "endTime",
                    "endedWithMemoryConstraint",
                    "isDirectQueryMode",
                    "isPartialReload",
                    "isSessionApp",
                    "name",
                    "peakMemoryBytes",
                    "reloadId",
                    "status",
                    "usage",
                    "__KEY_data_u0",
                    "__FK_data_u0",
                    (SELECT 
                        "description",
                        "error",
                        "line",
                        "lineNumber",
                        "__FK_errors"
                    FROM "errors" FK "__FK_errors"),
                    (SELECT 
                        "memory",
                        "__FK_size"
                    FROM "size" FK "__FK_size"),
                    (SELECT 
                        "@Value",
                        "__FK_statements"
                    FROM "statements" FK "__FK_statements" ArrayValueAlias "@Value"),
                    (SELECT 
                        "@Value" AS "@Value_u0",
                        "__FK_warnings"
                    FROM "warnings" FK "__FK_warnings" ArrayValueAlias "@Value_u0")
                FROM "data" PK "__KEY_data_u0" FK "__FK_data_u0"),
                (SELECT 
                    "ownerId",
                    "topLevelResourceId",
                    "spaceId",
                    "__KEY_extensions",
                    "__FK_extensions",
                    (SELECT 
                        "sub",
                        "subType",
                        "__FK_actor"
                    FROM "actor" FK "__FK_actor")
                FROM "extensions" PK "__KEY_extensions" FK "__FK_extensions"),
                (SELECT 
                    "__KEY_links",
                    "__FK_links",
                    (SELECT 
                        "Href",
                        "__FK_Self"
                    FROM "Self" FK "__FK_Self"),
                    (SELECT 
                        "href",
                        "__FK_self"
                    FROM "self" FK "__FK_self")
                FROM "links" PK "__KEY_links" FK "__FK_links")
            FROM "data" PK "__KEY_data" FK "__FK_data"),
            (SELECT 
                "Prev",
                "__KEY_links_u0",
                "__FK_links_u0",
                (SELECT 
                    "Href" AS "Href_u0",
                    "__FK_Self_u0"
                FROM "Self" FK "__FK_Self_u0"),
                (SELECT 
                    "Href" AS "Href_u1",
                    "__FK_Next"
                FROM "Next" FK "__FK_Next"),
                (SELECT 
                    "href" AS "href_u0",
                    "__FK_self_u0"
                FROM "self" FK "__FK_self_u0"),
                (SELECT 
                    "href" AS "href_u1",
                    "__FK_next"
                FROM "next" FK "__FK_next")
            FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
        FROM JSON (wrap on) "root" PK "__KEY_root"
        WITH CONNECTION (  
            URL "https://$(vu_tenant_fqdn)/api/v1/audits?limit=$(vu_audit_page_size)&sort=-eventTime&source=com.qlik/engine&eventType=com.qlik.v1.app.reload.finished$(vISO_8601_Date_Range)$(vNextURL)"
        );
        
        [AuditReload]:
        LOAD	
            Interval(Round(duration/1000)/(60*60*24),'hh:mm:ss.fff') AS ReloadDuration,
            duration / 86400000 AS ReloadDurationNum,
            TimeStamp([endTime]) AS ReloadEndTime,
            Date(TimeStamp([endTime]) - (Round(duration/1000)/(60*60*24))) AS ReloadStartDate,
            TimeStamp(Date(TimeStamp([endTime]) - (Round(duration/1000)/(60*60*24)))) AS ReloadStartTime,
            Hour(TimeStamp(Date(TimeStamp([endTime]) - (Round(duration/1000)/(60*60*24))))) AS ReloadStartHour,
            Minute(TimeStamp(Date(TimeStamp([endTime]) - (Round(duration/1000)/(60*60*24))))) AS ReloadStartMinute,
            Null() AS ReloadEngineTime,
            Round([peakMemoryBytes] / 1024 / 1024, 1) AS ReloadPeakReloadRAM_MB,
            Round([peakMemoryBytes] / 1024 / 1024 / 1024, 1) AS ReloadPeakReloadRAM_GB,
            [usage] AS ReloadUsage,
            [reloadId] AS ReloadID,
            'in app' AS ReloadType,
            Pick(Match([status],'ok','error'),'SUCCEEDED','FAILED') AS ReloadStatus,
            [__KEY_data_u0] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_AuditReloadKey],
            [__FK_data_u0] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
        RESIDENT RestConnectorMasterTable
        WHERE NOT IsNull([__FK_data_u0])
        AND (ApplyMap('Map_All_Reload_Jobs',reloadId)=1 OR SubStringCount(reloadId,'-')>0);
                                
        [AuditReloadErrors]:
        LOAD	
            [description] AS ReloadErrorDescription,
            [error] AS ReloadError,
            [line] AS ReloadLine,
            [lineNumber] AS ReloadLineNumber,
            [__FK_errors] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_AuditReloadKey]
        RESIDENT RestConnectorMasterTable
        WHERE NOT IsNull([__FK_errors]);

        [AuditReloadBaseRAMFootprint]:
        LOAD	
            [memory] AS BaseRAMFootprint,
            [__FK_size] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_AuditReloadKey]
        RESIDENT RestConnectorMasterTable
        WHERE NOT IsNull([__FK_size]);

        // [warnings]:
        // LOAD	[@Value],
        // 	[__FK_warnings] AS [_AuditReloadKey]
        // RESIDENT RestConnectorMasterTable
        // WHERE NOT IsNull([__FK_warnings]);

//         [AuditReloadLineageTemp]:
//         LOAD DISTINCT
// //             [connection],
//             If([storageProvider]='endpoints','[Unknown Endpoints Connection]',[connectionId]) AS DataConnectionID,
//             If([storageProvider]='endpoints','[Unknown Endpoints Connection]',[connectionId]) AS ReloadConnectionID,
//         // 	[dataSize],
//             [discriminator],
//         // 	[duration],
//         // 	[nbrOfFields],
//         // 	[nbrOfRows],
//         // 	[statement],
//        	 	[storageProvider] AS ReloadConnectionStorageProvider,
//             [type] AS ReloadConnectionType,
// //             [type],
//             [__FK_statements] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_AuditReloadKey]
//         RESIDENT RestConnectorMasterTable
//         WHERE NOT IsNull([__FK_statements])
//         AND (Len(connectionId)>=1 OR [storageProvider]='endpoints');
        
        [AuditReloadAppID]:
        LOAD	
            [topLevelResourceId] AS AppID,
            [__FK_extensions] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
        RESIDENT RestConnectorMasterTable
        WHERE NOT IsNull([__FK_extensions]);
        
        // [Self]:
        // LOAD	[Href],
        // 	[__FK_Self] AS [__KEY_links]
        // RESIDENT RestConnectorMasterTable
        // WHERE NOT IsNull([__FK_Self]);


        // [links]:
        // LOAD	[__KEY_links],
        // 	[__FK_links] AS [__KEY_data]
        // RESIDENT RestConnectorMasterTable
        // WHERE NOT IsNull([__FK_links]);

        [AuditReload2]:
        LOAD	
            [userId] AS ReloadUserID,
            [__KEY_data] & '|' & $(vCounter) & '|' & '$(vTenantID)' AS [__KEY_data]
        RESIDENT RestConnectorMasterTable
        WHERE NOT IsNull([__FK_data]);

        [NextURL]:
        LOAD	
            [href_u1] AS NextURL
        RESIDENT RestConnectorMasterTable
        WHERE NOT IsNull([__FK_next]);

        DROP TABLE RestConnectorMasterTable;

        LET vNextURL = TextBetween(Peek('NextURL',0,'NextURL'),'&next=',Null());
        
        IF SubStringCount('$(vNextURL)','&') >= 1 THEN
            LET vNextURL = TextBetween('$(vNextURL)',Null(),'&');
        END IF

        LET vNextURL = '&next=' & '$(vNextURL)';

        LET vNextURLRows = NoOfRows('NextURL');

        DROP TABLE NextURL;
        
        LET vCounter = $(vCounter) + 1;
        
    LOOP WHILE $(vNextURLRows)>0;

    IF NoOfRows('AuditReload') > 0 THEN
    
    	// JOIN APP ID
        LEFT JOIN(AuditReload)
        LOAD 
        	*
        RESIDENT AuditReloadAppID;
        
        DROP TABLE AuditReloadAppID;
        
        RENAME TABLE AuditReload TO TEMP;
        
        AuditReload:
        LOAD
        	*,
            AppID & '|' & Num(ReloadEndTime) AS MaxReloadKey
        RESIDENT TEMP;
        
        DROP TABLE TEMP;
    
        Map_MaxReloadKey:
        MAPPING LOAD DISTINCT
            AppID & '|' & Num(MaxReloadEndTime) AS MaxReloadKey,
            1
            ;
        LOAD
            Max(ReloadEndTime) AS MaxReloadEndTime,
            AppID
        RESIDENT AuditReload
        GROUP BY AppID;
        
        MostRecentAppReloads:
        NOCONCATENATE
        LOAD DISTINCT
            _AuditReloadKey,
            ReloadID,
            AppID
        RESIDENT AuditReload
        WHERE ApplyMap('Map_MaxReloadKey',MaxReloadKey)=1
        AND NOT WildMatch(AppID,'SessionApp_*');
        
        Map__AuditReloadKey:
        MAPPING LOAD DISTINCT
            _AuditReloadKey,
            1
        RESIDENT MostRecentAppReloads;
       
        Map__AuditReloadKey_AppID:
        MAPPING LOAD DISTINCT
            _AuditReloadKey,
            AppID
        RESIDENT AuditReload;
        
        Map___KEY_data_UserID:
        MAPPING LOAD DISTINCT
        	__KEY_data,
            ReloadUserID
        RESIDENT AuditReload2;
        
        Map__AuditReloadKey__KEY_data:
        MAPPING LOAD DISTINCT
        	_AuditReloadKey,
        	__KEY_data
        RESIDENT AuditReload;
        
        /////////////////////////////////////////////////////////////////////
        // LOOP OVER THE MOST RECENT OF EACH APP'S RELOAD TO GRAB THE LINEAGE
        /////////////////////////////////////////////////////////////////////
        
        FOR i=0 TO NoOfRows('MostRecentAppReloads')-1
        
        	LET vCurrentAuditReloadKey = Peek('_AuditReloadKey',$(i),'MostRecentAppReloads');
            LET vCurrentReloadID = Peek('ReloadID',$(i),'MostRecentAppReloads');
        	LET vCurrentAppID = Peek('AppID',$(i),'MostRecentAppReloads');
            
            // CHECK IF APP EXISTS
            
            LET vAPICallCounter = $(vAPICallCounter) + 1;        
            LIB CONNECT TO '$(vu_rest_connection)';

            RestConnectorMasterTable:
            SQL SELECT 
                "__KEY_root",
                (SELECT 
                    "resourceId",
                    "__KEY_data",
                    "__FK_data"
                FROM "data" PK "__KEY_data" FK "__FK_data")
            FROM JSON (wrap on) "root" PK "__KEY_root"
            WITH CONNECTION (  
                URL "https://$(vu_tenant_fqdn)/api/v1/items?resourceType=app&resourceId=$(vCurrentAppID)"
            );

            [CheckAppExists]:
            LOAD	
                [resourceId]
            RESIDENT RestConnectorMasterTable
            WHERE NOT IsNull([__FK_data]);

			DROP TABLE RestConnectorMasterTable;
            
            IF NoOfRows('CheckAppExists') > 0 THEN

                LET vAPICallCounter = $(vAPICallCounter) + 1;
                LIB CONNECT TO '$(vu_rest_connection)';

                RestConnectorMasterTable:
                SQL SELECT 
                    "reloadId",
                    "success",
                    "duration" AS "duration_u0",
                    "endTime",
                    "loadDataFilesBytes",
                    "loadFilesBytes",
                    "loadExternalBytes",
                    "storeFilesBytes",
                    "storeDataFilesBytes",
                    "isPartialReload",
                    "__KEY_data",
                    (SELECT 
                        "type",
                        "connectionId",
                        "connection",
                        "duration",
                        "dataSize",
                        "nbrOfFields",
                        "nbrOfRows",
                        "qri",
                        "label",
                        "tableName",
                        "partialReloadOperation",
                        "__FK_statements"
                    FROM "statements" FK "__FK_statements")
                FROM JSON (wrap off) "data" PK "__KEY_data"
                WITH CONNECTION (  
                    URL "https://$(vu_tenant_fqdn)/api/v1/apps/$(vCurrentAppID)/reloads/metadata/$(vCurrentReloadID)"
                );

                [AuditReloadLineageTemp]:
                LOAD	
                    '$(vCurrentAuditReloadKey)' AS [_AuditReloadKey],
                    If([connection]='endpoints','[Unknown Endpoints Connection]',ApplyMap('Map_DataConnectionID_DataConnectionType',[connectionId])) AS ReloadConnectionStorageProvider,
                    If([connection]='endpoints','[Unknown Endpoints Connection]',[connectionId]) AS DataConnectionID,
            		If([connection]='endpoints','[Unknown Endpoints Connection]',[connectionId]) AS ReloadConnectionID,
                    [type] AS ReloadConnectionType,
    //                 [reloadId],
    //                 [connectionId],
    //                 [connection],
    //                 [duration],
    //                 [dataSize],
    //                 [nbrOfFields],
    //                 [nbrOfRows],
    //                 [qri],
                    [label]
//                     tableName AS ReloadConnectionTableName
    //                 [partialReloadOperation],
    //                 [__FK_statements] AS [__KEY_data]
                RESIDENT RestConnectorMasterTable
                WHERE NOT IsNull([__FK_statements]);

    //             [data]:
    //             LOAD	
    //             	[reloadId],
    //                 [success],
    //                 [duration_u0] AS [duration_u0],
    //                 [endTime],
    //                 [loadDataFilesBytes],
    //                 [loadFilesBytes],
    //                 [loadExternalBytes],
    //                 [storeFilesBytes],
    //                 [storeDataFilesBytes],
    //                 [isPartialReload],
    //                 [__KEY_data]
    //             RESIDENT RestConnectorMasterTable
    //             WHERE NOT IsNull([__KEY_data]);

    //             [AuditReloadLineageTemp]:
    //             LOAD DISTINCT
    //     //             [connection],
    //                 If([storageProvider]='endpoints','[Unknown Endpoints Connection]',[connectionId]) AS DataConnectionID,
    //                 If([storageProvider]='endpoints','[Unknown Endpoints Connection]',[connectionId]) AS ReloadConnectionID,
    //             // 	[dataSize],
    //                 [discriminator],
    //             // 	[duration],
    //             // 	[nbrOfFields],
    //             // 	[nbrOfRows],
    //             // 	[statement],
    //                 [storageProvider] AS ReloadConnectionStorageProvider,
    //                 [type] AS ReloadConnectionType,
    //     //             [type],
    //                 [__FK_statements] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_AuditReloadKey]
    //             RESIDENT RestConnectorMasterTable
    //             WHERE NOT IsNull([__FK_statements])
    //             AND (Len(connectionId)>=1 OR [storageProvider]='endpoints');

                DROP TABLE RestConnectorMasterTable;
                
            END IF;
            
            DROP TABLE CheckAppExists;

        NEXT i;
        
        DROP TABLE MostRecentAppReloads;
        
        
        /////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////
        
        AuditReloadLineage:
        LOAD DISTINCT
        	*,
            FileName&'|'&DataConnectionID AS FileNameUnique
            ;
        LOAD DISTINCT
            *,
            If(ApplyMap('Map_FileExtensions',Lower(Subfield(label,'.',-1)))=1,Lower(Subfield(label,'.',-1))) AS FileType,
            If(ApplyMap('Map_FileExtensions',Lower(Subfield(label,'.',-1)))=1,Lower(Mid(label,Index(label,'/',-1)+1,Index(label,'.',-1)-Index(label,'/',-1)-1))) AS FileName,
            ReloadConnectionStorageProvider AS ReloadDataConnectionType
        RESIDENT AuditReloadLineageTemp;
        
//         Map__AuditReloadKey_ReloadDataConnectionType:
//         MAPPING LOAD DISTINCT
//         	_AuditReloadKey,
//             ReloadDataConnectionType
//         RESIDENT AuditReloadLineage;
        
        LEFT JOIN (AuditReload)
        LOAD * RESIDENT AuditReload2;

        LEFT JOIN (AuditReload)
        LOAD * RESIDENT AuditReloadBaseRAMFootprint;

        DROP FIELDS //discriminator
        			label
                    ,MaxReloadKey
                    ,__KEY_data
                    ;

        DROP TABLES AuditReload2
                    ,AuditReloadBaseRAMFootprint
                    ,AuditReloadLineageTemp
                    ;
        
        RENAME TABLE AuditReloadLineage TO TEMP;
        
        AuditReloadLineage:
        LEFT KEEP(AuditReload)
        LOAD 
        	*
        RESIDENT TEMP;
        
        DROP TABLE TEMP;
        
        RENAME TABLE AuditReloadErrors TO TEMP;
        
        AuditReloadErrors:
        LEFT KEEP(AuditReload)
        LOAD * RESIDENT TEMP;
        
        DROP TABLE TEMP;
            
        // COMBINE MODELS
        LEFT JOIN(Reloads)
        LOAD DISTINCT
        	_AuditReloadKey,
            ReloadID,
            ReloadPeakReloadRAM_GB,
            ReloadPeakReloadRAM_MB,
            BaseRAMFootprint,
            ReloadUsage
        RESIDENT AuditReload;
        	
        CONCATENATE(Reloads)
        LOAD DISTINCT
        	*
        RESIDENT AuditReload
        WHERE ApplyMap('Map_All_Reload_Jobs',ReloadID)<>1
        AND SubStringCount(ReloadID,'-')>0;
        
        DROP TABLE AuditReload;
        
        Map_NewAuditReloadIDs:
        MAPPING LOAD DISTINCT
        	AppID,
            1
        RESIDENT Reloads;
        
        DROP FIELD ReloadDataConnectionType;

	ELSE
    
        TRACE There are no reloads in this tenant yet. Dropping all tables and halting...;

        LET vNumTables = NoOfTables();

        FOR i = NoOfTables() - 1 TO 0 STEP - 1
            LET vTable = TableName($(i));
            TRACE Dropping table '$(vTable)';
            DROP TABLES [$(vTable)];
        NEXT

        TRACE All finished. Please try reloading again.;

        exit script;
      
    END IF

END SUB
///$tab Incremental
// For loading a table from QVD ///////////////////
SUB incremental
    
    If $(vIncrementalQVDsAvailable)=1 THEN
    
        LET qvd_name = '$(vOutputQVDName(Reloads,$(app_schema_version)))';

        TRACE Looking to load: $(qvd_name).;
        LET file_size = If(IsNull(FileSize('$(qvd_name)')),0,FileSize('$(qvd_name)'));

        IF file_size > 0 THEN
            TRACE File size is $(file_size) bytes;
            TRACE Fetching data from: $(qvd_name);
            
            Map__AuditReloadKey_AppID_FromQVD:
            MAPPING LOAD DISTINCT
                _AuditReloadKey,
                AppID
            FROM '$(qvd_name)'(qvd);
            
            Map__AuditReloadKey_ReloadEndTime_FromQVD:
            MAPPING LOAD DISTINCT
                _AuditReloadKey,
                ReloadEndTime
            FROM '$(qvd_name)'(qvd);
            
            Reloads:
            LOAD DISTINCT 
                * 
            FROM '$(qvd_name)'(qvd)
            WHERE ReloadEndTime >= Date('$(vMaxReloadAge)')
            AND NOT EXISTS(ReloadID);
            
            Map_AuditReloadKey_ReloadID:
            MAPPING LOAD DISTINCT
            	_AuditReloadKey,
                1
            RESIDENT Reloads;

        ELSE
            TRACE Could not find file: $(qvd_name).;
        END IF
            
        LET qvd_name = '$(vOutputQVDName(AuditReloadLineage,$(app_schema_version)))';

        TRACE Looking to load: $(qvd_name).;
        LET file_size = If(IsNull(FileSize('$(qvd_name)')),0,FileSize('$(qvd_name)'));

        IF file_size > 0 THEN
            TRACE File size is $(file_size) bytes;
            TRACE Fetching data from: $(qvd_name);

            AuditReloadLineage:
            LOAD DISTINCT 
                * 
            FROM '$(qvd_name)'(qvd)
            WHERE ApplyMap('Map_NewAuditReloadIDs',ApplyMap('Map__AuditReloadKey_AppID_FromQVD',_AuditReloadKey))<>1
            AND ApplyMap('Map__AuditReloadKey_ReloadEndTime_FromQVD',_AuditReloadKey) >= Date('$(vMaxReloadAge)')
            AND ApplyMap('Map_AuditReloadKey_ReloadID',_AuditReloadKey,'None')=1;

        ELSE
            TRACE Could not find file: $(qvd_name).;
        END IF
        
        LET qvd_name = '$(vOutputQVDName(AuditReloadErrors,$(app_schema_version)))';

        TRACE Looking to load: $(qvd_name).;
        LET file_size = If(IsNull(FileSize('$(qvd_name)')),0,FileSize('$(qvd_name)'));

        IF file_size > 0 THEN
            TRACE File size is $(file_size) bytes;
            TRACE Fetching data from: $(qvd_name);

            AuditReloadErrors:
            LOAD DISTINCT 
                * 
            FROM '$(qvd_name)'(qvd)
            WHERE ApplyMap('Map__AuditReloadKey_ReloadEndTime_FromQVD',_AuditReloadKey) >= Date('$(vMaxReloadAge)')
            AND ApplyMap('Map_AuditReloadKey_ReloadID',_AuditReloadKey,'None')=1;

        ELSE
            TRACE Could not find file: $(qvd_name).;
        END IF
            
    END IF
    
    // Create map later for OEM Dashboard support
    Map_ReloadID_TenantID:
    LOAD DISTINCT
        ReloadID,
        '$(vTenantID)' AS TenantID
    RESIDENT Reloads;

    IF NoOfRows('Reloads')>0 THEN
    	FOR EACH data_table IN 'Reloads','AuditReloadLineage','AuditReloadErrors'
        	LET qvd_name = '$(vOutputQVDName($(data_table),$(app_schema_version)))';
        	STORE $(data_table) INTO '$(qvd_name)'(qvd);
            LET file_size_$(data_table) = FileSize('$(qvd_name)');
        NEXT data_table
    END IF
    
  
END SUB
///$tab DC & Space Names
SUB conns_and_spaces_names
    IF NoOfRows('AuditReloadLineage')>0 THEN
    
        Map__AuditReloadKey_ReloadUserID:
        MAPPING LOAD DISTINCT
        	_AuditReloadKey,
        	ReloadUserID
        RESIDENT Reloads;
    
    	RENAME TABLE AuditReloadLineage TO TEMP;
        
        AuditReloadLineage:
        LEFT KEEP (DataConnections)
        LOAD
        	*,
            ApplyMap('Map_DataConnectionID_DataConnectionName',DataConnectionID,'[Deleted]') as ReloadDataConnectionName,
            If(Len(ApplyMap('Map_DataConnectionID_DataConnectionSpaceID',DataConnectionID))>0,
                  ApplyMap('Map_SpaceID_SpaceName',ApplyMap('Map_DataConnectionID_DataConnectionSpaceID',DataConnectionID,'[UNKNOWN]')),
                  'Personal - ' & ApplyMap('Map_UserID_$(vPersonalUserField)',ApplyMap('Map__AuditReloadKey_ReloadUserID',_AuditReloadKey)))
                AS ReloadDataConnectionSpaceName,
            If(Len(ApplyMap('Map_DataConnectionID_DataConnectionSpaceID',DataConnectionID))>0,
                  ApplyMap('Map_SpaceID_SpaceType',ApplyMap('Map_DataConnectionID_DataConnectionSpaceID',DataConnectionID,Null())),
                  'Personal')
                AS ReloadDataConnectionSpaceType
        RESIDENT TEMP;
        
        DROP TABLE TEMP;
    END IF
END SUB
///$tab Transform
SUB transform
    
    RENAME TABLE Spaces TO TEMP;
    
    Spaces:
    LEFT KEEP (Apps)
    LOAD * RESIDENT TEMP;
    
    DROP TABLE TEMP;
    
    RENAME TABLE ReloadTasks TO TEMP;
    
    ReloadTasks:
    LEFT KEEP (Apps)
    LOAD * RESIDENT TEMP;
    
    DROP TABLE TEMP;
    
    RENAME TABLE UserRoles TO TEMP;
    
    UserRoles:
    LEFT KEEP (Users)
    LOAD * RESIDENT TEMP;
    
    DROP TABLE TEMP;
    
    RENAME TABLE Map_AppOwner_Exists TO TEMP;
    
    Map_AppOwner_Exists:
    MAPPING LOAD DISTINCT
    	*
    RESIDENT TEMP;
    
    DROP TABLE TEMP;
    
    RENAME TABLE Map_AllApps_Temp TO TEMP;
    
    Map_AllApps_Final:
    MAPPING LOAD DISTINCT
    	*
    RESIDENT TEMP;
    
    DROP TABLE TEMP;
    
    RENAME TABLE Map_ReloadID_TenantID TO TEMP;
    
    Map_ReloadID_TenantID:
    MAPPING LOAD DISTINCT
    	*
    RESIDENT TEMP;
    
    DROP TABLE TEMP;

    RENAME TABLE Reloads TO TEMP;
    
    Reloads:
    NOCONCATENATE
    LOAD
    	*,
        Interval(ReloadStartTime-ReloadCreationTime,'hh:mm:ss') AS ReloadQueueDuration,
        If(MostRecentReloadCounterForLogAvailability<=10,'https://' & Coalesce('$(vu_tenant_fqdn_alias)','$(vu_tenant_fqdn)') & '/api/v1/apps/' & AppID & '/reloads/logs/' & ReloadID) AS ReloadLogURL
    WHERE ReloadStartTime>=Date('$(vInitialDaysBack)');
    LOAD
        _AuditReloadKey,
        TimeStamp(ReloadStartTime + $(vReloadTimeDiffFromGMT)) AS ReloadStartTime,
        Coalesce(Pick(Match(ReloadUsage,'ANALYTICS','DATA_PREPARATION','DATAFLOW_PREP','SINGLE_TABLE_PREP'),'App','Script','Data Flow','Single Table'),'Unknown') AS ReloadUsageType,
        AppID,
        ReloadUserID,
        Date(Floor(Date(TimeStamp(ReloadStartDate + $(vReloadTimeDiffFromGMT))))) AS ReloadStartDate,
        ReloadID,
        If(Previous(AppID)<>AppID,1,Peek(MostRecentReloadCounterForLogAvailability)+1) AS MostRecentReloadCounterForLogAvailability, // Only most recent 10 logs per app are available
        If(ReloadType='choreographer','chronos',ReloadType) AS ReloadType,
        ReloadStatus,
        ReloadDuration,
        ReloadDurationNum,
        TimeStamp(ReloadCreationTime + $(vReloadTimeDiffFromGMT)) AS ReloadCreationTime,
        Hour(TimeStamp(ReloadStartTime + $(vReloadTimeDiffFromGMT))) AS ReloadStartHour,
        ReloadStartMinute,
        TimeStamp(ReloadEndTime + $(vReloadTimeDiffFromGMT)) AS ReloadEndTime,
        TimeStamp(ReloadEngineTime + $(vReloadTimeDiffFromGMT)) AS ReloadEngineTime,
        ReloadPeakReloadRAM_MB,
        ReloadPeakReloadRAM_GB,
        BaseRAMFootprint
    RESIDENT TEMP
    ORDER BY AppID, ReloadStartTime DESC;

    DROP TABLE TEMP;
    DROP FIELD MostRecentReloadCounterForLogAvailability;
    
    CONCATENATE (Users)
    LOAD DISTINCT
    	ReloadUserID,
        Dual('[Deleted]',ReloadUserID) AS ReloadUserStatus,
        Dual('[Deleted]',ReloadUserID) AS ReloadUserName,
        Dual('[Deleted]',ReloadUserID) AS ReloadUserSubject,
        Dual('[Deleted]',ReloadUserID) AS ReloadUserEmail
    RESIDENT Reloads
    WHERE ApplyMap('Map_AppOwner_Exists',ReloadUserID)<>1;
    
    Map_ReloadID_ReloadPeakReloadRAM_MB:
    MAPPING LOAD DISTINCT
    	ReloadID,
        ReloadPeakReloadRAM_MB
    RESIDENT Reloads;
    
END SUB;
///$tab Reload Concurrency
SUB reload_concurrency

    RENAME TABLE Reloads TO TEMP;

    Reloads:
    LOAD DISTINCT
        *,
        If(ReloadStartTime>=$(vLast24Hours),1)AS Reloadlast24hours,
        If(ReloadStartTime>=$(vLast7Days),1)  AS Reloadlast7days,
        If(ReloadStartTime>=$(vLast30Days),1) AS Reloadlast30days,
        If(ReloadStartTime>=$(vLast60Days),1) AS Reloadlast60days,
        If(ReloadStartTime>=$(vLast90Days),1) AS Reloadlast90days,
        If(ReloadStartTime<$(vLast30Days) AND ReloadStartTime>=$(vLast60Days),1) AS [Reloadlast30-60days],
        If(ReloadStartTime<$(vLast60Days) AND ReloadStartTime>=$(vLast90Days),1) AS [Reloadlast60-90days],
        AutoNumber(If(Len(ReloadCreationTime)>0,ReloadCreationTime,ReloadStartTime) & '|' & ReloadEndTime) AS _ReloadExecutionConcurrencyKey // Will traverse tenants
    RESIDENT TEMP;

    DROP TABLE TEMP;

    // Establish Sort Order of Timeframe
    Timeframe_Temp:
    Load * Inline [
      Timeframe 
      Last 24 Hours
      Last 7 Days
      Last 30 Days
      Last 60 Days
      Last 90 Days
      Last 30-60 Days
      Last 60-90 Days
    ];

    Last_ReloadTime :
    NOCONCATENATE LOAD DISTINCT ReloadStartTime, 'Last 24 Hours' AS [ReloadTimeframe] RESIDENT Reloads WHERE Reloadlast24hours =1;
    CONCATENATE (Last_ReloadTime) LOAD DISTINCT ReloadStartTime, 'Last 7 Days'  AS [ReloadTimeframe] RESIDENT Reloads WHERE Reloadlast7days =1;
    CONCATENATE (Last_ReloadTime) LOAD DISTINCT ReloadStartTime, 'Last 30 Days' AS [ReloadTimeframe] RESIDENT Reloads WHERE Reloadlast30days=1;
    CONCATENATE (Last_ReloadTime) LOAD DISTINCT ReloadStartTime, 'Last 60 Days' AS [ReloadTimeframe] RESIDENT Reloads WHERE Reloadlast60days=1;
    CONCATENATE (Last_ReloadTime) LOAD DISTINCT ReloadStartTime, 'Last 90 Days' AS [ReloadTimeframe] RESIDENT Reloads WHERE Reloadlast90days=1;
    CONCATENATE (Last_ReloadTime) LOAD DISTINCT ReloadStartTime, 'Last 30-60 Days' AS [ReloadTimeframe] RESIDENT Reloads WHERE [Reloadlast30-60days]=1;
    CONCATENATE (Last_ReloadTime) LOAD DISTINCT ReloadStartTime, 'Last 60-90 Days' AS [ReloadTimeframe] RESIDENT Reloads WHERE [Reloadlast60-90days]=1;

    DROP FIELDS  Reloadlast24hours, Reloadlast7days, Reloadlast30days, Reloadlast60days, Reloadlast90days, [Reloadlast30-60days], [Reloadlast60-90days];
    DROP TABLE Timeframe_Temp;

    ReloadMinMaxDates:
    LOAD
        If(Min("ReloadCreationTime")>0,Min("ReloadCreationTime"),Min("ReloadStartTime")) AS "Reload Start Time Min",
        Max("ReloadEndTime") AS "Reload End Time Max"
    RESIDENT Reloads
    WHERE If(Len("ReloadCreationTime")>0,"ReloadCreationTime","ReloadStartTime") >= Date('$(vMaxReloadConcurrencyDaysBack)');

    LET vReloadMinDate = Peek('Reload Start Time Min',0,'ReloadMinMaxDates');
    LET vReloadMaxDate = Peek('Reload End Time Max',0,'ReloadMinMaxDates');
    LET vReloadMinDateFloor = Date(Floor('$(vReloadMinDate)'));
    LET vReloadMaxDateFloor = Date(Floor('$(vReloadMaxDate)'));
    LET vMinutes = Ceil(($(vReloadMaxDate)-$(vReloadMinDate))*24*(60/$(vConcurrencyMinutes)));

    DROP TABLE ReloadMinMaxDates;

    ConcurrencyMinutesTemp:
    LOAD DISTINCT
        TimeStamp(Round(Date($(vReloadMinDate)+((1/24/(60/$(vConcurrencyMinutes)))*RowNo())), 1/24/60/60)) AS ReloadConcurrencyMinute
    AUTOGENERATE $(vMinutes);

    LEFT JOIN IntervalMatch (ReloadConcurrencyMinute) 
    LOAD 
        If(Len(ReloadCreationTime)>0,ReloadCreationTime,ReloadStartTime) AS ReloadStartTime, 
        ReloadEndTime
    RESIDENT Reloads;

    ReloadConcurrencyMinutes:
    LOAD
        ReloadConcurrencyMinute,
        AutoNumber(ReloadStartTime & '|' & ReloadEndTime) AS _ReloadExecutionConcurrencyKey // Will traverse tenants
    RESIDENT ConcurrencyMinutesTemp;

    DROP TABLE ConcurrencyMinutesTemp;

    LEFT JOIN (ReloadConcurrencyMinutes)
    LOAD
        ReloadID,
        _ReloadExecutionConcurrencyKey,
        ReloadCreationTime,
        ReloadStartTime
    RESIDENT Reloads;

    RENAME TABLE ReloadConcurrencyMinutes TO TEMP;

    ReloadConcurrencyMinutes:
    LOAD
        ReloadID,
        ApplyMap('Map_ReloadID_ReloadPeakReloadRAM_MB',ReloadID,0) AS ReloadPeakReloadRAM_MB_Concurrency,
        ReloadConcurrencyMinute,
        If(ReloadConcurrencyMinute<ReloadStartTime,'QUEUED','RELOADING') AS ReloadConcurrencyMinuteStatus
    RESIDENT TEMP;

    DROP TABLE TEMP;

    DROP FIELD _ReloadExecutionConcurrencyKey FROM Reloads;
    
    ReloadTotalMinDate:
    LOAD
        Date(Floor(If(Min("ReloadCreationTime")>0,Min("ReloadCreationTime"),Min("ReloadStartTime")))) AS "Reload Start Time Total Min"
    RESIDENT Reloads;
    
    LET vMinTotalReloadMinDate = Peek('Reload Start Time Total Min',0,'ReloadTotalMinDate');
    LET vMaxReloadDate = Today(1);
    LET vMaxReloadDateMonthEnd = MonthEnd(Today(1));
    
    DROP TABLE ReloadTotalMinDate;

    ReloadDates:
    LOAD
        *,
        Dual(ReloadStartYear & '-' & ReloadStartMonth,MonthStart(ReloadStartDate)) AS ReloadStartYearMonth
        ;
    LOAD
        *,
        Year(ReloadStartDate) AS ReloadStartYear,
        Month(ReloadStartDate) AS ReloadStartMonth,
        Date(WeekStart(ReloadStartDate)) AS ReloadStartWeek,
        WeekDay(ReloadStartDate) AS ReloadStartWeekDay,
        If(InMonth(ReloadStartDate,'$(vMaxReloadDate)',0),1,0) AS ReloadInCMFlag,
        If(InMonth(ReloadStartDate,'$(vMaxReloadDate)',-1),1,0) AS ReloadInPMFlag,
        If(ReloadStartDate<=Date('$(vMaxReloadDate)'),0,1) AS ReloadForecastFlag,
        1 AS ReloadDateCounter
    ;
    LOAD
        Date(StartDate + IterNo() - 1 ) AS ReloadStartDate,
        Date(StartDate + IterNo() - 1 ) AS ReloadStartDateAlias
    While StartDate + IterNo() - 1 <= EndDate;
    LOAD * INLINE [
        StartDate, 				EndDate
        $(vMinTotalReloadMinDate), $(vMaxReloadDateMonthEnd)
    ];

    ReloadDurationBuckets:
    LOAD
        StartTime,
        EndTime,
        Dual(ReloadDurationBucket,Interval#(StartTime,'HH:mm:ss')) AS ReloadDurationBucket
    INLINE [
        StartTime,		EndTime,		ReloadDurationBucket
        00:00:00,		00:29:59,		< 00:30
        00:30:00,		00:59:59,		>= 00:30 < 1:00
        01:00:00,		01:29:59,		>= 1:00 < 1:30
        01:30:00,		01:59:59,		>= 1:30 < 2:00
        02:00:00,		02:29:59,		>= 2:00 < 2:30
        02:30:00,		02:59:59,		>= 2:30 < 3:00
        03:00:00,		99:99:99,		>= 3:00
    ];

    IntervalMatch(ReloadDuration)
    LEFT JOIN
    LOAD
        StartTime,
        EndTime
    RESIDENT ReloadDurationBuckets;

    LEFT JOIN (Reloads)
    LOAD DISTINCT
        ReloadDuration,
        ReloadDurationBucket
    RESIDENT ReloadDurationBuckets;

    RENAME TABLE ReloadDurationBuckets TO TEMP;

    ReloadDurationBuckets:
    LOAD
        ReloadDurationBucket
    RESIDENT TEMP;

    DROP TABLE TEMP;
    
END SUB
///$tab AutoNumber
SUB autonumber
	
    AUTONUMBER
    	_AuditReloadKey
        ,_UserKey
        ,FileNameUnique
        ;
    
    LEFT JOIN(Apps)
    LOAD DISTINCT
    	AppID,
        'False' AS AppIsDeleted,
        'True' AS ExcludeDeletedAppsToggle
    RESIDENT Apps;
    
    LEFT JOIN(Spaces)
    LOAD DISTINCT
    	SpaceID,
        Dual(SpaceName,AutoNumber(SpaceID)) as SpaceNameUnique
    RESIDENT Spaces;
        
    LEFT JOIN(Apps)
    LOAD DISTINCT
    	AppID,
        Dual(AppName,AutoNumber(AppID)) as AppNameUnique
    RESIDENT Apps;
    
    CONCATENATE (Apps)
    LOAD DISTINCT
    	AppID,
        'True' AS AppIsDeleted,
        Dual('[Deleted]',AutoNumber(AppID)) AS AppName,
        '[Unknown]' AS SpaceID,
        ApplyMap('Map_ReloadID_TenantID',ReloadID) AS TenantID,
        '[Unknown]' AS AppCreatedTime,
        '[Unknown]' AS AppUpdatedTime,
        '[Unknown]' AS AppCreatorID,
        '[Unknown]' AS AppUpdaterID,
        '[Unknown]' AS AppIsFavorited,
        '[Unknown]' AS AppDescription,
        '[Unknown]' AS AppHasSectionAccess,
        '[Unknown]' AS AppOwnerID,
        '[Unknown]' AS AppLastReloadTime,
        '[Unknown]' AS AppLastReloadTimeLocalServerTime,
        '[Unknown]' AS AppOriginalID,
        '[Unknown]' AS AppOwnerSubject,
        '[Unknown]' AS AppOwnerName,
        '[Unknown]' AS AppOwnerEmail,
        '[Unknown]' AS AppPublishedTime,
        '[Unknown]' AS AppEncrypted,
        '[Unknown]' AS AppSpaceName,
        Dual('[Deleted]',AutoNumber(AppID)) AS AppNameUnique
    RESIDENT Reloads
    WHERE ApplyMap('Map_AllApps_Final',AppID)<>1;
    
    RENAME TABLE DataConnections TO TEMP;
    
    DataConnections:
    NOCONCATENATE LOAD
    	*,
        If(DataConnectionNameUniqueTemp='[Unknown Endpoints Connection]',DataConnectionNameUniqueTemp,Dual(DataConnectionName,AutoNumber(DataConnectionID))) AS DataConnectionNameUnique
    RESIDENT TEMP;
    
    DROP TABLE TEMP;
    DROP FIELD DataConnectionNameUniqueTemp;
    
    LEFT JOIN(ReloadTasks)
    LOAD DISTINCT
    	ReloadTaskID,
        Dual(ReloadTaskName,AutoNumber(ReloadTaskID)) as ReloadTaskNameUnique
    RESIDENT ReloadTasks;
    
END SUB
///$tab Multi-Tenant
Sub write_tenant_qvds(location, sub_dir, name, is_parent)
  Trace Storing QlikMetaCollection QVDs.;
  
  Let location = If(Right('$(location)',1)='/',Left('$(location)',Len('$(location)')-1),'$(location)');
  
  If $(is_parent)=0 then
  	Let vFullLocation = '$(location)/QlikMetaCollection/Tenants/$(vTenantID)/$(sub_dir)/$(name)';
  Else
  	Let vFullLocation = '$(location)/QlikMetaCollection/CompiledTenants/$(sub_dir)/$(name)';
  End if

  For i = 0 to NoOfTables()-1
    Let vTableName = TableName($(i));
    Trace Storing $(vTableName).;
    Store $(vTableName) Into [$(vFullLocation)/$(vTableName).qvd](qvd);
    Trace $(vTableName) stored!;
  Next i
  
End Sub

Sub load_multi_tenant_qvds(location, sub_dir, name)

	Let vDirLocation = If(Right('$(location)',1)='/',Left('$(location)',Len('$(location)')-1),'$(location)');
    Let vAnyFileFound = 0;

	Let vTenants = 1;
	For Each Dir in DirList('$(vDirLocation)/QlikMetaCollection/Tenants/')

	  Let vFolder = '$(Dir)$(sub_dir)/$(name)/';
      Let vTenant = TextBetween('$(vFolder)','$(vDirLocation)/','/$(sub_dir)/');
      Trace --------------------;
      Trace Looking to load data for Tenant: $(vTenant);
      Trace --------------------;

	  Let vTenantFileFound = 0;
      For Each file in FileList('$(vFolder)')
        If WildMatch('$(file)','*.qvd') THEN
          Let vAnyFileFound = 1;
          Let vTenantFileFound = 1;
          
	      Let vTableName = TextBetween(Subfield('$(file)','/',-1),Null(),'.qvd');
          "$(vTableName)":
          Load Distinct
              *
          From [$(file)](qvd);
        End If
      Next file
      
      If $(vTenantFileFound) then
      	Trace Completed loading QVDs for Tenant: $(vTenant);
        Let vTenants = $(vTenants) + 1;
      Else
        Trace No QVDs were found for Tenant: $(vTenant);
      End If
              
    Next Dir
    
    Let vTenants = $(vTenants) - 1;
    
    If $(vAnyFileFound)>0 then
      Trace --------------------;
      Trace Successfully loaded data from $(vTenants) Tenants!;
      Trace --------------------;
    Else
      Trace --------------------;
      Trace No QVDs were Found! Confirm that this directory is the parent directory of "QlikMetaCollection".;
      Trace --------------------;
    End If


End Sub
///$tab Helper Functions
SUB execute_sub(sub_routine)
  Trace Working on $(sub_routine);
  Let sub_start = Num(Now(1));
  Call $(sub_routine)
  Let sub_finish = Num(Now(1));
  Let sub_duration = Num(Round((sub_finish-sub_start)*86400),'#,##0');
  Trace $(sub_routine) completed after $(sub_duration) seconds.;
END SUB
///$tab Main
//// App Variables & Messaging
SET ThousandSep=',';
SET DecimalSep='.';
SET MoneyThousandSep=',';
SET MoneyDecimalSep='.';
SET MoneyFormat='$ ###0.00;-$ ###0.00';
SET TimeFormat='h:mm:ss TT';
SET DateFormat='M/D/YYYY';
SET TimestampFormat='M/D/YYYY h:mm:ss[.fff] TT';
SET FirstWeekDay=6;
SET BrokenWeeks=1;
SET ReferenceDay=0;
SET FirstMonthOfYear=1;
SET CollationLocale='en-US';
SET CreateSearchIndexOnReload=1;
SET MonthNames='Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec';
SET LongMonthNames='January;February;March;April;May;June;July;August;September;October;November;December';
SET DayNames='Mon;Tue;Wed;Thu;Fri;Sat;Sun';
SET LongDayNames='Monday;Tuesday;Wednesday;Thursday;Friday;Saturday;Sunday';
SET NumericalAbbreviation='3:k;6:M;9:G;12:T;15:P;18:E;21:Z;24:Y;-3:m;-6:μ;-9:n;-12:p;-15:f;-18:a;-21:z;-24:y';

// Reset these variables
LET reload_start 	= Now(1);
SET start_msg=; 
SET comp=;
Let vTenants = 0;

SET app_name			= 'Reload Analyzer';
SET app_version			= '4.1.2';
SET app_schema_version	= 'sv_1.0.0';
LET comp 				= ComputerName(); 
LET engine_ver 			= PurgeChar(EngineVersion(),Chr(39)); 
LET start_msg 			= 'Reloading $(app_name) $(app_version) from $(comp) running QIX Engine version $(engine_ver)';

Trace $(startMsg);

SUB load_core_data
    Trace Loading data...;
    For Each sub_routine in 'check_version','get_quota','get_tasks_feature','get_tenant_metadata','get_users','get_spaces','get_data_connections','get_apps','get_reloads','get_reload_tasks','get_tasks','get_audit_reloads','incremental','conns_and_spaces_names'
        Call execute_sub(sub_routine)
    Next sub_routine
    
    If $(vu_track_app_meta_over_time) then
        Call store_app_meta_rolling
    End If
END SUB

SUB transform_data
    Trace Transforming data...;
    For Each sub_routine in 'transform','reload_concurrency','autonumber'
        Call execute_sub(sub_routine)
    Next sub_routine
END SUB


// Main
If $(vu_multi_tenant_enabled)=1 then 
    If $(vu_is_parent_app)=1 then
        Trace This application is configured for a Multi-Tenant setup and has been designated as a **Parent** app.;
        Trace This application will attempt to load all of the QVDs that have been generated for the $(app_name) within the "QlikMetaCollection" folder found within "$(vu_qlik_meta_collection_parent_dir)";
        Trace This application will then store all resulting QVDs to a "CompiledTenants" directory.;
        
        Call execute_sub('variables')
        Call execute_sub('load_multi_tenant_qvds(''$(vu_qlik_meta_collection_parent_dir)'',''Monitoring'',''$(app_name)'')')

        If $(vTenants)>0 then
        	Call execute_sub('get_user_field')
            Call transform_data
        End If
        
        Trace This application will attempt to store all of the tables from this model to the "QlikMetaCollection/CompiledTenants" folder found within $(vu_qlik_meta_collection_parent_dir);
  		Call execute_sub('write_tenant_qvds(''$(vu_qlik_meta_collection_parent_dir)'',''Monitoring'',''$(app_name)'',1)')
        
        Trace Data fetched from $(vTenants) tenants.;
    Else
        Trace This application is configured for a Multi-Tenant setup and has been designated as a **Child** app.;
        Trace This application will attempt to store all of the tables from this model to the "QlikMetaCollection" folder found within "$(vu_qlik_meta_collection_parent_dir)";
		
        Call execute_sub('variables')
        Call load_core_data
        Call execute_sub('write_tenant_qvds(''$(vu_qlik_meta_collection_parent_dir)'',''Monitoring'',''$(app_name)'',0)')
        Call execute_sub('get_user_field')
        Call transform_data
    End If
Else
    Call execute_sub('variables')
    Call load_core_data
    Call execute_sub('get_user_field')
    Call transform_data

    Trace Data fetched from $(vu_tenant_fqdn);
End If

LET reload_end = Now(1);
LET reload_duration = Num(Ceil((reload_end-reload_start)*86400),'#,##0');
LET reload_message = 'At $(reload_end), $(app_name) v$(app_version) finished reloading on $(comp) (QIX Engine $(engine_ver)) after $(reload_duration) seconds.';
Trace $(reload_message);
